/**
 * Markus.js base file
 * @module markus.js
 */
 /**
 The global namespace. This is the Global namespace in **all** the files
 @class Global
 */

/**
This is the global object that holds the version and build info
@property markus
@type Object
*/
var markus = {
    version: "0.3.4.1",
    build: "201602005"
};

/**
Some JQuery extensions
@class JQuery
**/

/**
New JQuery function definition. Scrolls to the element that is passed
as a parameter.
Example Usage:
  `$('#div_element2').goTo();`
*Source:*
https://stackoverflow.com/questions/4801655/how-to-go-to-a-specific-element-on-page

@method goto
@param {Object} element the element we want to scroll to
 */
( function($) {
$.fn.goto = function() {
    $('html, body').animate({
        scrollTop: $(this).offset().top + 'px'
    }, 'fast');
    return this; // for chaining...
}
} )(window.jQuery);

/**
New JQuery function definition. Replaces all elements passed to this functions
with the specified element name.

Example Usage:
``$('div').replaceTagName('span');`

*Source:*
https://stackoverflow.com/questions/2815683/jquery-javascript-replace-tag-type
@method replaceTagName
@param {String} replaceWith the string you want to replace the element name with
*/
( function($) {
$.fn.replaceTagName = function(replaceWith) {
    var tags = [],
        i = this.length;
    while (i--) {
        var newElement = document.createElement(replaceWith),
            thisi = this[i],
            thisia = thisi.attributes;
        for (var a = thisia.length - 1; a >= 0; a--) {
            var attrib = thisia[a];
            newElement.setAttribute(attrib.name, attrib.value);
        }
        ;
        newElement.innerHTML = thisi.innerHTML;
        $(thisi).after(newElement).remove();
        tags[i] = newElement;
    }
    return $(tags);
};
} )(window.jQuery);
;/**
 * Comment.js base file.
 * @module comment.js
 */

 /**
 The class that holds the variables and functions created in the namespace of this file.
 The constrcutor of this object is only called once, because it is an anonymous function.

 The functions defined in this class are later added to the MARKUS global object and can
 from that point on be called as `markus.comments.FUNCTION_NAME`

 @class comment.js_anonymous
 @constructor
 @param {Object}  _m a reference to the Markus Configuration Object is passed
 **/
( function(_m) {

/**
 * Finds all comments for this element, stores their text contents into an array,
 * and sets this array as value atribute (after Unicode Escaping) for the `span`
 * comment Container. Finally it triggers a click event on the commentIcon span
 *
 * @for Comment
 * @method saveComment
 */
var saveComment = function() {
    //hold all the pre element textcontent in an array
    var comments = [];
    $("#commentHolder .comment").each(function() {
        comments.push($(this).find("pre").text());
    });

    //check if there is a newComment, if there is, also add it
    var newComment = $.trim($("#comment .commentTextArea").val());
    if (newComment.length > 0) {
        comments.push(newComment);
    }

    //Log the comments to be saved and reset the newComment field
    console.log(JSON.stringify(comments));
    $("#comment .commentTextArea").val("");

    //Find the span with the ID of the markus passageID and class of commentContainer
    var obj = $("span[id='" + $("#commentHolder").attr("data-markus-passageId") + "'] .commentContainer");

    //set the value attribute to the array of comments, and unicodeEscape it
    obj.attr("value", JSON.stringify(comments));
    obj.attr("value", markus.util.convertToEscapeUnicode(obj.attr("value")));

    //Set the attribute that contains the number of comments that are stored on this object
    obj.attr("data-markus-noOfComment", (comments.length == 0) ? "" : comments.length);

    //Finally trigger a click event on the commentIcon to save the data
    $("span[id='" + $("#commentHolder").attr("data-markus-passageId") + "'] span[type='commentIcon']").trigger("click");
};


/**
 * Handles the removing of a comment. It first removes the comment, and then
 * resaves all the ones that are still left.
 *
 * @for Comment
 * @method removeAnySync
 * @param  {Event} event The event Object that is passed
 */
var removeAnySync = function(event) {
    event.stopPropagation();

    //Get the ID of the comment we want to remove and remove that one
    var removeCommentId = $(this).attr("data-markus-commentId");
    $("#commentHolder .comment[data-markus-commentId='" + removeCommentId + "']").remove();

    //push all the leftover comments into an array
    var comments = [];
    $("#commentHolder .comment").each(function() {
        comments.push($(this).find("pre").text());
    });


    //Find the span with the ID of the markus passageID and class of commentContainer
    var obj = $("span[id='" + $("#commentHolder").attr("data-markus-passageId") + "'] .commentContainer");

    //set the value attribute to the array of comments, and unicodeEscape it
    obj.attr("value", JSON.stringify(comments));
    obj.attr("value", markus.util.convertToEscapeUnicode(obj.attr("value")));
    //set the data-markus-noOfComment value to the amount of comments
    obj.attr("data-markus-noOfComment", (comments.length == 0) ? "" : comments.length);
    // obj.text(convertToEscapeUnicode(obj.attr("value")));
    // $("span[id='" + $("#commentHolder .panel-group").attr("data-markus-passageId") + "'] .commentContainer").attr("value", convertToEscapeUnicode(JSON.stringify(comments)));

    //click the span within the .doc class with the right passageID
    $(".doc span[id='" + $("#commentHolder").attr("data-markus-passageId") + "'] span[type='commentIcon']").trigger("click");
};

/**
 * Enables the editing of the provided comment. It starts the editing of it
 * by setting the panel-body to contenteditable and chaning the edit to a save
 * button.
 *
 * @for Comment
 * @method edit
 * @param  {Event} event the propagated event from the DOM
 */
var edit = function(event) {
    event.stopPropagation();

    //find the id of the comment we're working on
    var commentId = $(this).attr("data-markus-commentId");

    //finds the commentHolder and sets a few settings to allow it to be edited.
    $("#commentHolder .comment[data-markus-commentId='" + commentId + "'] .panel-body").prop("contenteditable", "true");
    $("#commentHolder .comment[data-markus-commentId='" + commentId + "'] .collapse").collapse('show');
    $("#commentHolder .comment[data-markus-commentId='" + commentId + "'] span[type='comment-edit']").attr("type", "comment-save").removeClass("glyphicon-edit").addClass("glyphicon-floppy-disk");
};

/**
 * Saves the current commentField. It escape Unicode Characters
 *
 * @for Comment
 * @method save
 * @param  {Event} event The event that is passed from the DOM
 */
var save = function(event) {
    event.stopPropagation();

    //Finds the comment we inted to save
    var commentId = $(this).attr("data-markus-commentId");

    //Saves the content from the commentHolder, and formats it, and stops the editing process
    var content = $("#commentHolder .comment[data-markus-commentId='" + commentId + "'] .panel-body").html();
    $("#commentHolder .comment[data-markus-commentId='" + commentId + "'] .panel-body").html(content.replace(/<\/pre><pre>/gm, "\n"));
    $("#commentHolder .comment[data-markus-commentId='" + commentId + "'] .panel-body").prop("contenteditable", "false");
    $("#commentHolder .comment[data-markus-commentId='" + commentId + "'] span[type='comment-save']").attr("type", "comment-edit").addClass("glyphicon-edit").removeClass("glyphicon-floppy-disk");

    //Gets all the comments and pushes them in an array to be saved
    var comments = [];
    $("#commentHolder .comment").each(function() {
        comments.push($(this).find("pre").text());
    });

    //Setting the value of the commentHolder to the comments array and
    //Escaping Unicode Characters.
    var obj = $("span[id='" + $("#commentHolder").attr("data-markus-passageId") + "'] .commentContainer");
    obj.attr("value", JSON.stringify(comments));
    obj.attr("value", markus.util.convertToEscapeUnicode(obj.attr("value")));
    obj.attr("data-markus-noOfComment", (comments.length == 0) ? "" : comments.length);
};

/**
 * Called upon parsing of the document to parse the comment UI from the data in the html
 * document. This goes through all the comments and sanitizes them.
 *
 * @for Comment
 * @method startAddingCommentHolder
 */
var startAddingCommentHolder = function() {
    //For each of the passages in the document
    $(".doc .passage").each(function() {
        //If there is no commentContainer content, make one default one
        if ($(this).find(".commentContainer").length == 0) {
            $(this).prepend("<span class='commentContainer' value='[]'><span class='glyphicon glyphicon-comment' type='commentIcon' style='display:none' aria-hidden='true' data-markus-passageId='" + $(this).attr('id') + "'></span></span>");
        } else {
            //If there is conent in the commentContainer, we look through it

            //Find all the commentIcons and remove them
            var commentIcons = $(this).find("[type='commentIcon']");
            for (var i = 1; i < commentIcons.length; i++) {
                commentIcons[i].remove();
            }

            //Find the Commentcontainer
            var commentContainer = $(this).find(".commentContainer");
            //And read back all the comments from JSOn into a JS Array (after converting it back into UNICode)
            var comments = $.parseJSON(markus.util.converBackToUnicode($(commentContainer[0]).attr("value")));

            //If there are any leftOver commentContainers, we remove them after taking their contents
            for (var i = 1; i < commentContainer.length; i++) {
                comments = comments.concat($.parseJSON(markus.util.converBackToUnicode($(commentContainer[i]).attr("value"))));
                $(commentContainer[i]).remove();
            }

            //Set the value of the commentContainer to the JSON data equivalent of the JS array
            $(commentContainer[0]).attr("value", JSON.stringify(comments));
            //convertToEscapeUnicode on the contents
            $(commentContainer[0]).attr("value", markus.util.convertToEscapeUnicode($(commentContainer[0]).attr("value")));
        }
    });

    //Try to find the user Authentication profile.
    //If it succeeds, and the user has a name, you show the comments field
    $.getJSON("/auth/profile_info", function(result) {
        if (result["name"]) {
            $(".doc span[type='commentIcon']").show();
        } else {
            $(".doc span[type='commentIcon']").hide();

        }

    //If the User Authentication request fails, hide by default
    }).fail(function() {
        $(".doc span[type='commentIcon']").hide();
    });

};
/**
 * This class' method are defined in the above anonymous class of this file and
 * are only reassigned here.
 *
 * Make all the functions that have been defined above availabe through
 * markus.comment.FUNCTION, to allow calling of them throughout the DOM
 * @class Comment
 */
_m.comment = {
    saveComment: saveComment,
    removeAnySync: removeAnySync,
    startAddingCommentHolder: startAddingCommentHolder,
    edit: edit,
    save: save

};
} )(markus);

/**
 * Adds all the UI Event handles for the Comment UI. This class links the UI to
 * the functions behind the scenes.
 *
 * @for Global
 * @method registerCommentUI
 */
var registerCommentUI = function() {
    $("#comment").hide();
    $("#comment .addCommentBtn").on("click", markus.comment.saveComment);
    $("#comment .closeComment").on("click", function() {
        $("#comment").hide();
        $("#assist").show();
    });
    $("#commentHolder").on("click", "span[type='comment-trash']", markus.comment.removeAnySync);
    $("#commentHolder").on("click", "span[type='comment-edit']", markus.comment.edit);
    $("#commentHolder").on("click", "span[type='comment-save']", markus.comment.save);
};

/**
 *  Defines what happens when you click the commentIcon. It generates a new commentHolder
 *
 * @for Global
 * @method registerCommentIcon
 */
var registerCommentIcon = function() {
    $(".doc").on("click", "span[type='commentIcon']", function() {

        //If it is currently not visible, we need to show it and hide the assist
        if ( ($("#comment").css('display') == 'none') ) {
            $("#assist").hide();
            $("#comment").show();
        }

        //Remove the commentClass object from the comment and set the passageID
        $("#comment .comment").remove();
        $("#commentHolder").attr("data-markus-passageId", $(this).attr("data-markus-passageId"));

        //Get a list of comments for this passage from the passage and try to convert it back to Unicode
        var comments = $(this).parent().attr("value") || "[]";
        comments = $.parseJSON(markus.util.converBackToUnicode(comments));

        //For each of those comments
        for (var i = comments.length - 1; i >= 0; i--) {
            var comment = comments[i];
            // $("#commentHolder .panel-group").attr("data-markus-passageId", $(this).parent().attr("id"));

            //add a new panel to the commentHolder
            $("#commentHolder .panel-group").prepend('<div class="panel panel-default comment" data-markus-commentId="' + i + '"> \
            <div class="panel-heading" role="tab" id="heading' + i + '" aria-expanded="false"> \
              <h4 class="panel-title"> \
                <a role="button" data-toggle="collapse" data-parent="#accordion" href="#collapse' + i + '" aria-expanded="true" aria-controls="collapse' + i + '">'
                + comment.substring(0, 10) + "..." +
                '</a> <span class="pull-right glyphicon glyphicon-trash" type="comment-trash" data-markus-commentId="' + i + '"></span> <span class="pull-right glyphicon glyphicon-edit" type="comment-edit" data-markus-commentId="' + i + '"></span>\
              </h4> \
            </div> \
            <div id="collapse' + i + '" class="panel-collapse collapse" role="tabpanel" aria-labelledby="heading' + i + '"> \
              <div class="panel-body"><pre>'
                + comment +
                '</pre></div> \
            </div> \
          </div>');
        }

        //Set the position of the commentHolder and show it on the page
        $("#commentHolder").css("top", $(this).position().top).show();
    });
};
;/**
 * data.js base file.
 * @module data.js
 */

/**
 * Here the Markus.Data methods are defined and added to the Global Markus Singleton.
 * The Data methods handle mostly data conversion
 *
 * @class Data
 * @constructor
 */
_m.data = {

    /**
     * Returns an array that, depending on the provided parameters will return the
     * markups in the passage or in the whole document. And depending on the Boolean flag
     * withSupportText it returns its surrounding text.
     *
     * @method getMarkupsArray
     * @param  {Boolean} withPassage     Do we want to include the passage
     * @param  {Boolean} withSupportText Do we want to include support Text
     * @param  {int} noOfChars       The number of chars to get
     * @return {Array}                 An Array of markups
     */
    getMarkupsArray: function(withPassage, withSupportText, noOfChars) {
        //Defines the variables used, and checks data that has been passed
        var content = [];
        var withPassage = withPassage || false;
        var noOfChars = noOfChars || 10;
        var withSupportText = withSupportText || false;
        var count = 0;

        //If we want the `withSupportText`, then we increase the randomID.
        if (withSupportText) {
            $(".doc").find(".markup[type]").each(function() {
                $(this).attr("data-MARKUS-randomID", count++);
            });

        }

        //If we want to find a specific passage and the passage and entry do exist
        if (withPassage && $(".doc").find(".passage,.entry").length > 0) {
            //For each of the found passages
            $(".doc").find(".passage,.entry").each(function() {
                //get the text
                var text = $(this).html().replace(/\n/gm, "");

                //If this object is not hidden or halfTransparent
                if (!$(this).hasClass("hidden") && !$(this).hasClass("halfTransparent")) {
                    //We get its passageID
                    var passageId = $(this).attr("id");

                    //For each of the markup class instances found
                    $(this).find(".markup[type]").each(function() {
                        //Get its type, tag and id
                        var type = $(this).attr("type");
                        var tag = $(this).text();
                        var id = $(this).attr("cbdbid") || $(this).attr(type + "_id") || "";
                        var obj = {
                            passageId: passageId,
                            type: type,
                            id: markus.util.converBackToUnicode(id)
                        };
                        //If we want to include supportText, we give before and after text
                        if (withSupportText) {
                            var headAndTail = text.split($(this)[0].outerHTML);
                            obj["textBeforeTag"] = (headAndTail.length > 0) ? (headAndTail[0]).replace(/<[^>]*>/gm, "").slice(-noOfChars) : "";
                            obj.tag = tag;
                            obj["textAfterTag"] = (headAndTail.length > 1) ? (headAndTail[1]).replace(/<[^>]*>/gm, "").slice(0, noOfChars) : "";
                        } else {
                            obj.tag = tag;
                        }

                        //Push this one markup record into the content array
                        content.push(obj);
                    });

                    //For each of the commentContainers
                    $(this).find(".commentContainer").each(function() {
                        //We get all the comments in that container
                        var comments = $.parseJSON(markus.util.converBackToUnicode($(this).attr("value")));
                        var type = "comment";

                        //For each of those comments
                        for (var i = 0; i < comments.length; i++) {
                            //We once again get its tag, id and create an object out of it
                            var tag = comments[i];
                            var id = i;
                            var obj = {
                                passageId: passageId,
                                type: type,
                                id: id
                            };
                            //If we need support text, we add that, but that is not possible in this case.
                            if (withSupportText) {
                                obj["textBeforeTag"] = "";
                                obj.tag = tag;
                                obj["textAfterTag"] = "";
                            } else {
                                obj.tag = tag;
                            }

                            //Add the created comment record to the array of content.
                            content.push(obj);
                        }

                    });

                }

            });
        } else {
          //ELSE we are looking through the complete document

            //For each of the markups found
            $(".doc").find(".markup[type]").each(function() {
                //We record the type, tag, id and create an object out of it
                var type = $(this).attr("type");
                var tag = $(this).text();
                var id = $(this).attr("cbdbid") || $(this).attr(type + "_id") || "";
                var obj = {
                    type: type,
                    id: markus.util.converBackToUnicode(id)
                };

                //We grab some supporting text surrounding it according to the flag.
                if (withSupportText) {
                    var headAndTail = text.split($(this)[0].outerHTML);
                    obj["textBeforeTag"] = (headAndTail.length > 0) ? (headAndTail[0]).replace(/<[^>]*>/gm, "").slice(-noOfChars) : "";
                    obj.tag = tag;
                    obj["textAfterTag"] = (headAndTail.length > 1) ? (headAndTail[1]).replace(/<[^>]*>/gm, "").slice(0, noOfChars) : "";
                } else {
                    obj.tag = tag;
                }

                //And once the record of the markup is done we add it to the content list.
                content.push(obj);
            });
        }

        //From all the markup types remove the attribute data-MARKUS-randomID
        $(".doc").find(".markup[type]").removeAttr("data-MARKUS-randomID");

        //Now that we have created this array, return it to the requestor
        return content;
    },

    /**
     * Turns an array of objects into a CSV array.
     *
     * @method objArrayToCSV
     * @param  {Array} objArray the array to turn into a CSV
     * @return {String}         The CSV data string
     */
    objArrayToCSV: function(objArray) {
        //Will hold the CSV data lines
        var content = [];

        //If there are actually objects to parse
        if (objArray.length > 0) {
            var keys = [];
            var header = [];
            //for each key in the objArray, add it to the header Array
            for (var k in objArray[0]) {
                keys.push(k);
                header.push(k.replace(/,/gm, '\,'));
            }

            //Add the header as the first line, describing the CSV format
            content.push(header.join(","));

            //For each of the data indeces in the objArray
            for (var dIndex in objArray) {
                //Get a temp array index
                var _temp = objArray[dIndex];
                var _row = [];
                for (var kIndex in keys) {
                    //Write a row of CSV data
                    _row.push('"' + ("" + _temp[keys[kIndex]]).replace(/"/gm, '""') + '"');
                }
                //Join it on a ',' and add it to the CSV lines
                content.push(_row.join(","));
            }

        }

        //Return the contentArray after joining it on newlines.
        return content.join("\n");
    },

    /**
     * Turns an array of objects into a TSV array.
     *
     * @method objArrayToTSV
     * @param  {Array} objArray the array to turn into a TSV
     * @return {String}         The TSV data string
     */
    objArrayToTSV: function(objArray) {
        //Will hold the CSV data lines
        var content = [];

        //If there are acutally any objects to parse
        if (objArray.length > 0) {
            var keys = [];
            var header = [];
            //For each of the keys in the first line
            for (var k in objArray[0]) {
                keys.push(k); header.push(k.replace(/\t/gm, '_'));
            }

            //Push the first dataline, being the data header line. Joined on a '\t'
            content.push(header.join("\t"));
            for (var dIndex in objArray) {
                var _temp = objArray[dIndex];
                var _row = [];
                for (var kIndex in keys) {
                    //Write a single data line
                    _row.push('"' + ("" + _temp[keys[kIndex]]).replace(/"/gm, '""') + '"');
                }
                content.push(_row.join("\t"));
            }
        }
        //Join all the datalines on a newline and return the resulting TSV string
        return content.join("\n");
    },

    /**
     * Returns the provided array as a HTML table.
     *
     * @method objArrayToHTML
     * @param  {Array} objArray the array of objects we want to convert
     * @return {String}        the table of the array
     */
    objArrayToHTML: function(objArray) {
        var content = [];
        //If we have any objects to parse
        if (objArray.length > 0) {
            //First create the table, and on top of it create the data header
            content.push("<table id='exportTable' class='export'>");
            var keys = [];
            content.push("<thead><tr>");
            for (var k in objArray[0]) {
                keys.push(k);
                content.push("<td>" + k + "</td>");
            }

            //Now create the actualy data body lines. These are the actual data objects
            content.push("</tr></thead><tbody>");
            for (var dIndex in objArray) {
                var _temp = objArray[dIndex];
                content.push("<tr>");
                for (var kIndex in keys) {
                    //Write the keys into table cells
                    content.push("<td>" + _temp[keys[kIndex]] + "</td>");
                }
                content.push("</tr>");
            }
            //Add the closing of the tableBody and table.
            content.push("</tbody></table>");
        }
        //Return the resulting HTML table
        return content.join("");
    }

};


} )(markus);
;/**
 * helpInfo.js base file.
 * @module helpInfo.js
 */


  /**
  The class that holds the variables and functions created in the namespace of this file.
  The constrcutor of this object is only called once, because it is an anonymous function.

  @class helpInfo.js_anonymous
  @constructor
  @param {Object}  _m a reference to the Markus Configuration Object is passed
  **/
( function(_m) {

    //Define the new HelpInfo object
    _m.helpInfo = {};

    /**
     * In this method we load the specific help template according to the language
     * cookie.
     *
     * @method loadHelpInfo
     */
    var loadHelpInfo = function() {
        var lang = $.cookie('lang') || "";
        if ($("#helpModal").length > 0) {
            $("#helpModal").load("help" + lang + ".html", {}, function() {
                registHelp();
            });
        }
    }


    /**
     * Registers the eventHandlers for the help menu.
     *
     * @method registHelp
     */
    var registHelp = function() {
        // alert("regist Help");
        markus.ui.colorSwitcher.regist("#helpModal button.switcher", "#helpModal");

        //Shows the modal help button on click
        $('#showHelpModalBtn').on("click", function() {

            $('#helpModal').modal('show');
        });

        //Hides the modal popover on scroll
        $('#helpModal .modal-body').scroll(function() {
            $('#helpModal').find(".popover").hide();
            $('.selected').removeClass("selected");
        });

        //Hides the modal popover on click
        $('#helpModal').on("click", function() {
            $('#helpModal').find(".popover").hide();
            $('.selected').removeClass("selected");
        });

        //Refresh the modal on scroll
        $('#helpModal').on('shown.bs.modal', function() {
            $('[data-spy="scroll"]').each(function() {
                $(this).scrollspy('refresh')
            });
        });

        //When you click on the markupSample button the function below triggers.
        $(document).on("click", ".markupSample", sampleMarkupClicked);
    };

    /**
     * Defines what happens when you click the sampleMarkup. Basically, creates contents
     * and shows/hides things depending on what you clicked.
     *
     * @method sampleMarkupClicked
     * @param  {Event} event the event that is passed from the DOM (i.e. the mouse click)
     */
    var sampleMarkupClicked = function(event) {
        //Logging for debug purposes
        console.log("sampleName");
        console.log($(this).html());

        //If the markupSample already exists, just return.
        if ($(this).find(".markupSample").length > 0) {
            return;
        }

        //prevent the event from bubbling through the event chain
        event.stopPropagation();

        //Hide the cbdbIdPopover and sample1Popover
        $("#sampleCbdbIdPopover").hide();
        $("#sample1Popover").hide();

        //calculate the offset and find the parent of this element.
        var offset = $(this).offset();
        var _parent = $(this).parent();

        //Get a reference to self.
        var obj = this;

        // remove previous selected tag and set the current as selected
        $(".selected").removeClass("selected");
        $(this).addClass("selected");

        //Find the samplePopover, hide its tagText, and get the tagtext from the current markupSample
        var popover = $("#sample1Popover");
        popover.find(".tagText").hide();
        var tagText = $(obj).text();

        // console.log("sample1Popover");
        /*
          start
          Nested multi tags detect and show popup
        */

        //Hide the typePopoverContent, remove the noColor class and hide it.
        var typePopoverContent = popover.find(".typePopoverContent");
        typePopoverContent.hide();
        typePopoverContent.find("button").removeClass("noColor").hide();

        //A flag that holds if this tag is the same as its parent
        var sameTag = false;

        //If you are identical to your parent
        while (_parent.is(".markup") && _parent.text() == tagText) {
            sameTag = true;
            //Keep showing markups that are contained in the parent
            typePopoverContent.find("." + $(_parent).attr("type")).show();
            _parent = _parent.parent();
        }
        //Logging of the sameTag status
        console.log("sameTag = " + sameTag);

        //If there was an identical tag, show that popOver
        if (sameTag) {
            typePopoverContent.find("." + $(this).attr("type")).show();
            typePopoverContent.show();
        }
        /*
          end nested multi tags
        */
        // clickedMarkup = $(this);
        // if (otherTags.length > 0){
        $("#sample1Popover").find(".search").show();
        // $("#sample1Popover").find(".trash").hide();
        // }else {
        $("#sample1Popover").find(".trash").show();
        // $("#sample1Popover").find(".search").hide();
        // }
        // console.log($(this).attr("cbdbid"));

        //Set the offset of the sample1Popover
        $("#sample1Popover").show().offset({
            top: offset.top + $(this).height() / 2 - $("#sample1Popover").outerHeight() / 2,
            left: offset.left + $(this).outerWidth() + 11
        });

        //If this has a class of fullName or partialName
        if ($(this).hasClass("fullName") || $(this).hasClass("partialName")) {
            var colorClass = "";
            var cbdbIdPopover = $("#sampleCbdbIdPopover");
            var cbdbIdPopoverContent = cbdbIdPopover.find("#sampleCbdbIdPopoverContent");

            //Set the color based on what name it is
            if ($(this).hasClass("fullName")) {
                colorClass = "btn-danger" ;
                cbdbIdPopoverContent.addClass("has-error").removeClass("has-warning");
            } else {
                colorClass = "btn-warning";
                cbdbIdPopoverContent.addClass("has-warning").removeClass("has-error");
            }

            //Remove the popoOvercontent button
            cbdbIdPopoverContent.find("button").remove();

            //If the cbdbid attribute does not yet exist, we create it.
            if (!$(this).attr("cbdbid")) {
                $(this).attr("cbdbid", "");
            }
            //Split multiple associated ids
            var cbdbids = $(this).attr("cbdbid").split("|");
            var cbdbIdsHTML = "";

            //For each of the split associated cbdbIDs
            for (var i = 0; i < cbdbids.length; i++) {
                //As long as it is an actual cbdbid (length > 0)
                if (cbdbids[i].length > 0) {
                    //Create a button with inline styling.
                    cbdbIdsHTML += "<button class='btn " + colorClass + " btn-xs' style='margin-bottom: 1px;'>" + cbdbids[i] + "</button> ";
                }
            }

            //Set the offset of the sampleCbdbIdPopover.
            $("#sampleCbdbIdPopover").addClass("top").removeClass("bottom").show().offset({
                top: offset.top - $("#sampleCbdbIdPopover").outerHeight() - 11,
                left: offset.left + $(this).outerWidth() / 2 - $("#sampleCbdbIdPopover").outerWidth() / 2
            });

            //Prepend the cbdbIdsHTML tot the content
            $(cbdbIdPopoverContent).prepend(cbdbIdsHTML);
        }
        console.log("after");
    }

    //Register the helpInfo.register function to the loadHelpInfo defined above
    _m.helpInfo.register = function() {
        loadHelpInfo();
    }
} )(markus);
;/**
 * io.js base file.
 * @module io.js
 */

 /**
 The class that holds the variables and functions created in the namespace of this file.
 The constrcutor of this object is only called once, because it is an anonymous function.

 The functions defined in this class are later added to the MARKUS global object and can
 from that point on be called as `markus.io.FUNCTION_NAME`

 @class io.js_anonymous
 @constructor
 @param {Object}  _m a reference to the Markus Configuration Object is passed
 **/
( function(_m) {
/**
 * Creates an error Handler function. This function prints out the error message
 * prefaced by 'Error', to make it easier to spot in the console log.
 *
 * @method ERROR_HANDLER
 * @param  {Error} e The error that has happened
 */
var ERROR_HANDLER = function(e) {
    console.log('Error: ' + e.message);
};

/**
 * Updates the color switchers for the tagNames. This is called on load. It
 * hides or shows buttons depending on their visibility and changes the color-switcher-class
 * based on their status
 *
 * This method is defined in the io.js anonymous function but later attached to the `markus.io` object
 *
 * @for IO
 * @method updateSwitchers
 */
var updateSwitchers = function() {
    //If there are buttons on the buttonsRow
    if ($("#buttonsRow").length > 0) {

        //For each of the tagNames that have been defined in the markus tag module
        for (var tagName in _m.tag) {
            //Either use the predefined buttonName or just the tagname and get the status of the tag
            var buttonName = _m.tag[tagName]["buttonName"] || tagName;
            var status = _m.tag[tagName]["status"] || "";

            //If we can't find the color-switcher-class for that tagName
            if ($("#buttonsRow").find("button[color-switcher-class='" + tagName + "']").length == 0) {
                //We add a color-switcher-class for that tagName
                $("#buttonsRow").prepend('<button type="button" class="btn btn-sm switcher ' + tagName + ' ' + status + '" color-switcher-class="' + tagName + '" data-toggle="tooltip" data-placement="auto" title="" data-original-title="click to change color">' + buttonName + '</button> ');
            } else {
                if (_m.tag[tagName]["buttonName"]) {
                  //Else just update the class and add 'status'
                    $("#buttonsRow").find("button[color-switcher-class='" + tagName + "']").text(buttonName).addClass(status);
                }
            }

            //If the current tag is visible
            var visible = _m.tag[tagName]["visible"];
            if (!visible) {
                //If the button is not visible, hide it
                $("#buttonsRow").find("button[color-switcher-class='" + tagName + "']").hide();
            }
        }
    } else {
        //If there are no buttons yet, try again in 3 seconds
        setTimeout(updateSwitchers, 3000);
    }
};


/**
 * Updates the .singleTagContent in the manualPopover. It handles their visibility
 * based on the 'visible' property and sets the button text according to either
 * the tagName or a predefined buttonName that can override the tagName.
 *
 * This method is defined in the io.js anonymous function but later attached to the `markus.io` object
 *
 * @for IO
 * @method updateManualPopover
 */
var updateManualPopover = function() {
    //For each of the tagNames defined in the markus.tag module
    for (var tagName in _m.tag) {
        //get the predefined buttonName or just use the tagName
        var buttonName = _m.tag[tagName]["buttonName"] || tagName;

        //If it cant find a button witht the type of tagName in the manualPopover
        if ($("#manualPopover .singleTagContent").find("button[_type='" + tagName + "']").length == 0) {
            //We add one if it can't be found
            $("#manualPopover .singleTagContent").prepend('<button type="button" _type="' + tagName + '" class="btn btn-xs switch ' + tagName + ' switcher noColor">' + buttonName + '</button>');
        } else {
            if (_m.tag[tagName]["buttonName"]) {
                //If it can be found we set the buttonName if it has been explicitly set (predefined)
                $("#manualPopover .singleTagContent").find("button[_type='" + tagName + "']").text(buttonName);
            }
        }

        //Hide or show the button based on their 'visible' status
        var visible = _m.tag[tagName]["visible"];
        if (!visible) {
            $("#manualPopover .singleTagContent").find("button[_type='" + tagName + "']").hide();
        }
    }
};

/*
var attr = $(this).attr('name');

// For some browsers, `attr` is undefined; for others,
// `attr` is false.  Check for both.
if (typeof attr !== typeof undefined && attr !== false) {
    // ...
}
*/

/**
 * This method generates all the necessary CSS classes for a new tagType. It will Also
 * overwrite already existing definitions so you can use this to redefine the styling of existing
 * tags too.
 *
 * This method is defined in the io.js anonymous function but later attached to the `markus.io` object
 *
 * @for IO
 * @method newTagCSS
 * @param  {String} tagName    the name of the tagClass we want to generate in CSS
 * @param  {String} buttonName the name we want the button to have for this tagCSS
 * @param  {String} tagColor   16 bit hex color (e.g. ``#FF0000` = red.) you can use css shortcuts like `red` or `#f00`
 */
var newTagCSS = function(tagName, buttonName, tagColor) {
    //before adding a new tagCSS definition, remove any already existing definition for this tagName
    removeTagCSS(tagName);
    buttonName = buttonName || tagName;
    _m.tag = _m.tag || {};

    //If the tag has not been defined yet, we define an object for it in the markus.tag global object
    if (_m.tag[tagName] == null) {
        _m.tag[tagName] = {
            color: tagColor,
            buttonName: buttonName,
            visible: true,
            status: ""
        };
    } else {
        //If it has already been defined, overwrite the color setting to the color we apparently want.
        _m.tag[tagName].color = tagColor;
    }

    //Set the markus.tagCSS object to an empty array that we're going to redefine
    _m.tagCSS[tagName] = [];

    //we set both the border and background for this button to the provided tagColor
    $.stylesheet('button.' + tagName, ['background-color', 'border-color'], tagColor);
    //set the foreground color (i.e. text) to white
    $.stylesheet('button.' + tagName, ['color'], "#fff");

    //Also push the foreground color rule into the markus.tagCSS array
    _m.tagCSS[tagName].push({
        tagName: 'button.' + tagName,
        cssKey: ["color"],
        cssValue: "#fff"
    });
    //Now push the background and border color rule into the markus.tagCSS array
    _m.tagCSS[tagName].push({
        tagName: 'button.' + tagName,
        cssKey: ['background-color', 'border-color'],
        cssValue: tagColor
    });

    // tagCSS['.'+tagName].push($.stylesheet('.'+tagName).rules()[0].cssText);

    //We set the color for any element that just has the class of `tagName` to the tagColor
    $.stylesheet('.' + tagName, {
        "color": tagColor
    });
    //Duplicate the above rule into the markus.tagCSS array
    _m.tagCSS[tagName].push({
        tagName: '.' + tagName,
        cssKey: ["color"],
        cssValue: tagColor
    });


    //set the background color and border color of a selected and tagName element to tagColor
    $.stylesheet('.selected.' + tagName, ['background-color', 'border-color'], tagColor);
    //Duplicate the above rule into the markus.tagCSS array
    _m.tagCSS[tagName].push({
        tagName: '.selected.' + tagName,
        cssKey: ['background-color', 'border-color'],
        cssValue: tagColor
    });

    //Set the border color of the 'bordered' and tagname element to the provided tagColor
    $.stylesheet('.bordered.' + tagName, ['border-color'], tagColor);
    //Duplicate the above rule into the markus.tagCSS array
    _m.tagCSS[tagName].push({
        tagName: '.bordered.' + tagName,
        cssKey: ['border-color'],
        cssValue: tagColor
    });

};

/**
 * Called before defining new CSS rules for a tagType. This removes any pre-existing rules for
 * the provided tagType from the markus.tag and markus.tagCSS objects.
 *
 * This method is defined in the io.js anonymous function but later attached to the `markus.io` object
 *
 * @for IO
 * @method removeTagCSS
 * @param  {String} tagName The tag you want to remove
 */
var removeTagCSS = function(tagName) {
    //Remove the CSS for the reference from both the markus.tagCSS and markus.tag object
    delete _m.tagCSS[tagName]
    ;
    delete _m.tag[tagName]
    ;
};

/**
 * This function handles the loading of the CSS rules from the saved HTML document using
 * the tag and tagCSS attributes. It has a couple of failsafes in case the data is missing
 * and also contains the defaults for the standard tagNames (i.e. placeName, officialTitle, timePeriod etc.)
 *
 * This method is defined in the io.js anonymous function but later attached to the `markus.io` object
 *
 * @for IO
 * @method loadCSSFromCSS_TagAtt
 */
var loadCSSFromCSS_TagAtt = function() {
    //find the tagCSS and tag attributes of the doc
    var tagCSSAttr = $(".doc").attr("tagCSS");
    var tagAttr = $(".doc").attr("tag");

    //If the found the tagCSS variables are indeed actually populated with data, we try to populate them
    //But at the same time, the tag attribute for the CSS has not been set yet, so we need to redefine those
    if ((typeof tagCSSAttr !== typeof undefined && tagCSSAttr !== false) && (typeof tagAttr === typeof undefined || tagAttr === false || tagAttr === "{}")) {
        //Read the tagCSS by evaluating JSON from the tagCSS attr.
        var tagCSS = _m.tagCSS = $.evalJSON($(".doc").attr("tagCSS"));
        var tagRebuilt = {};

        //For each of the predefined tags we re-add them back to the stylesheet
        for (var tag in _m.tagCSS) {
            var cssArray = tagCSS[tag];
            for (var cssIndex in cssArray) {
                css = cssArray[cssIndex];
                //We re-create the css rules
                if (css.tagName == "." + tag) {
                    newTagCSS(css.tagName, css.tagName, css.cssValue);
                }
            }
        }
        //redefine the document attribute tag to the JSON stringified version of the markus.tag object
        $(".doc").attr("tag", JSON.stringify(_m.tag));
        tagAttr = $(".doc").attr("tag");
    }

    //If we find tagCSS attribute we also add the stuff to the styleSheet in the same manner as above
    if (typeof tagCSSAttr !== typeof undefined && tagCSSAttr !== false) {
        var tagCSS = _m.tagCSS = $.evalJSON($(".doc").attr("tagCSS"));
        var cssArray;
        var css;
        for (var tag in tagCSS) {
            cssArray = tagCSS[tag];
            for (var cssIndex in cssArray) {
                css = cssArray[cssIndex];
                $.stylesheet(css.tagName, css.cssKey, css.cssValue);
            //style += $.stylesheet(css.tagName).rules()[0].cssText;
            }
        }
    }

    //If we found a tagAttribute we load its definitions into the markus.tag object using JQuery.evalJSON
    //Converting escaped Unicode Characters back
    if (typeof tagAttr !== typeof undefined && tagAttr !== false) {
        _m.tag = $.evalJSON(markus.util.converBackToUnicode($(".doc").attr("tag")));

        //For each of the tagNames defined in the markus.tag object
        //We write the css class to the markus.tagCSS object and the JQuery stylesheet
        for (var tagName in _m.tag) {
            var tagColor = _m.tag[tagName].color;
            _m.tagCSS[tagName] = [];

            //Set the foreground color for the .tagName class
            $.stylesheet('.' + tagName, {
                "color": tagColor
            });
            //Duplicate into CSS
            _m.tagCSS[tagName].push({
                tagName: '.' + tagName,
                cssKey: ["color"],
                cssValue: tagColor
            });

            //Set the selected.tagName class' background and border color to the provided tagColor
            $.stylesheet('.selected.' + tagName, ['background-color', 'border-color'], tagColor);
            //Duplicate into the markus.tagCSS array
            _m.tagCSS[tagName].push({
                tagName: '.selected.' + tagName,
                cssKey: ['background-color', 'border-color'],
                cssValue: tagColor
            });

            //Set the .bordered.tagName class' border-color to the tagColor
            $.stylesheet('.bordered.' + tagName, ['border-color'], tagColor);
            //Duplicate into the markus.tagCSS array
            _m.tagCSS[tagName].push({
                tagName: '.bordered.' + tagName,
                cssKey: ['border-color'],
                cssValue: tagColor
            });

            //Set the button.tagName class' back and border color to the provided tagColor
            $.stylesheet('button.' + tagName, ['background-color', 'border-color'], tagColor);
            //Set the foreground color for the button.tagName class to the provided tagColor
            $.stylesheet('button.' + tagName, ['color'], "#fff");
            //Duplicate into the markus.tagCSS array
            _m.tagCSS[tagName].push({
                tagName: 'button.' + tagName,
                cssKey: ["color"],
                cssValue: "#fff"
            });
            //Duplicate into the markus.tagCSS array
            _m.tagCSS[tagName].push({
                tagName: 'button.' + tagName,
                cssKey: ['background-color', 'border-color'],
                cssValue: tagColor
            });
        }

    }

    //Check if the definition for fullName exists, if not, redefine it
    _m.tag["fullName"] = _m.tag["fullName"] || {
        buttonName: "姓名",
        visible: true,
        color: "#d9534f",
        status: ""
    };
    //Check if the definition for partialName exists, if not, redefine it
    _m.tag["partialName"] = _m.tag["partialName"] || {
        buttonName: "別名",
        visible: true,
        color: "#f0ad4e",
        status: ""
    };
    //Check if the definition for placeName exists, if not, redefine it
    _m.tag["placeName"] = _m.tag["placeName"] || {
        buttonName: "地名",
        visible: true,
        color: "#428bca",
        status: ""
    };
    //Check if the definition for officialTitle exists, if not, redefine it
    _m.tag["officialTitle"] = _m.tag["officialTitle"] || {
        buttonName: "官名",
        visible: true,
        color: "#5bc0de",
        status: ""
    };
    //Check if the definition for timePeriod exists, if not, redefine it
    _m.tag["timePeriod"] = _m.tag["timePeriod"] || {
        buttonName: "時間",
        visible: true,
        color: "green",
        status: ""
    };

    //Update the switchers and the manualPopovers
    updateSwitchers();
    updateManualPopover();
};

/**
 * Calling this method automates the download/export of the file. This generates
 * a click event on the `#export` button
 *
 * @for io.js_anonymous
 * @method autoDownload
 * @param  {Object} fileEntry The fileEntry object that contains the file
 * @param  {String} suffix    Filetype extension as String, or just a suffix
 */
var autoDownload = function(fileEntry, suffix) {
    $("#saving_temp").remove();
    $('#export').attr("href", fileEntry.toURL()).attr("download", $('.doc').attr('filename') + suffix);
    $('#export')[0].click();
};

/**
 * Calling this method will clean the data from the document into a newly spawned,
 * temporary element to use JQuery to clean it from unwanted elements and classes
 *
 * @for io.js_anonymous
 * @method saveSave
 * @param  {String} filename the fileName for the new File
 * @param  {Object} _fn      The fileEntry object
 */
var saveSave = function(filename, _fn) {
    //Prepends the temporary saving span, this is an invisible span
    $("body").prepend($("<span id='saving_temp' style='display:none'></span>"));

    //Gets a jquery ref to the just prepened element
    var div = $("#saving_temp");

    // Set the html content of this temp element to the document outerHTML.
    div.html(($(".doc")[0]).outerHTML);

    //Remove all instances of .notSave and iframes
    div.find(".notSave,iframe").remove();
    //If we find a .justSelected or .justExtend instance, remove that class
    div.find(".justSelected,.justExtended").removeClass("justSelected").removeClass("justExtended");
    //If there is any markup left with the randomID, remove that attribute
    div.find(".markup[randomID]").removeAttr("randomID");

    //get the saveContent, now that it is cleaned before saving back from the temp element
    var saveContent = $("#saving_temp").html();

    //Call the saveFile function
    saveFile(filename, _m.util.recoverAllExistTag(saveContent), _fn);

    //Now that we're done with the temporary element, remove it from the doc
    $("#saving_temp").remove();

};

/**
 * Generates a TEI XML document from the HTML document that is generated in the browser.
 *
 * @for io.js_anonymous
 * @method saveTEI
 * @param  {String} filename the fileName for the new File
 */
var saveTEI = function(filename) {
    //Define the TEI head
    var head = '<?xml version="1.0" encoding="UTF-8"?><TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:xi="http://www.w3.org/2001/XInclude"><teiHeader><fileDesc><titleStmt><title>' + filename + '</title></titleStmt><publicationStmt><p/></publicationStmt><sourceDesc><p/></sourceDesc></fileDesc></teiHeader><text><body>';
    //The closing tags needed to close of the TEI document
    var tail = "</body></text></TEI>";
    //Concatenate the head, content and tail
    var saveContent = head + convertTEI(($(".doc")[0]).outerHTML) + tail;

    //Call the saveFile function
    saveFile(filename, saveContent, function(fileEntry) {
        $('#export').attr("href", fileEntry.toURL()).attr("download", $('.doc').attr('filename') + "_tei.xml");
        $('#export')[0].click();
    });
};

/**
 * Generates a standalone HTML document that you can view offline. This has all the data from the
 * document stored in it, including the stylesheet CSS rules that have been parsed into one single
 * `<style>` tag in the head of the HTML document.
 *
 * @for io.js_anonymous
 * @method saveHTML
 * @param  {String} filename the name of the new file
 */
var saveHTML = function(filename) {
    //Define the head of the document for a standalone HTML document
    var head = "<html><head><meta charset='utf-8'/></head><link rel='stylesheet' href='http://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css'><style>.noCBDBID{border-bottom:thin solid red}.previous{display:none}name,persName{background:red}pre{white-space:pre-wrap;white-space:-moz-pre-wrap;white-space:-pre-wrap;white-space:-o-pre-wrap;word-wrap:break-word}.unsolved{font-size:large}.fullName{color:#b94a48}.partialName{color:orange}.nianhao{color:green}.markup .markup.unsolved{border-right:medium dotted red}.placeName{color:#428bca}.doc{padding:10px}.moreThanOneId{border-bottom:medium dotted red}.moreThanOneId.wrong{border-bottom:0}#drop_zone{border:2px dashed #fff;-moz-border-radius:5px;-webkit-border-radius:5px;border-radius:5px;padding:25px;text-align:center;font:20pt bold Vollkorn;color:#fff}#content{padding-top:20px}div.layout{text-align:center}div.centre{text-align:left;width:10px;display:block;margin-left:auto;margin-right:auto}.stop-scrolling{height:100%;overflow:hidden}.markup.noColor{color:inherit}.officialTitle{color:#5f9ea0}.btn.noColor{background-color:silver;border-color:rgba(0,0,0,0);color:inherit}.markup.selected{padding-right:5px;padding-left:5px;line-height:1.5;border-radius:3px;color:#fff}.selected .markup{color:#fff}.fullName.selected{background-color:#d9534f;border-color:#d43f3a}.partialName.selected{background-color:#f0ad4e;border-color:#eea236}.nianhao.selected{background-color:#5cb85c;border-color:#4cae4c}.placeName.selected{background-color:#428bca;border-color:#357ebd}.officialTitle.selected{background-color:#5bc0de;border-color:#46b8da}#helpModal .modal-header{display:none}.popover .btn{color:#fff}.hidden {display:none}.halfTransparent {opacity:0.3}</style>";
    //Define some more tails and heads for needed HMTL structure
    var bodyhead = "<body><div class='container'><div class='row row-offcanvas row-offcanvas-right'>";
    var bodytail = "</div></div>";
    var tail = "</body></html>";

    //Turn all of the styleTags that have been created into a single style tag embedded in the document
    var style = "<style>";
    var tagCSS = _m.tagCSS;
    for (var tag in tagCSS) {
        cssArray = tagCSS[tag];
        for (var cssIndex in cssArray) {
            css = cssArray[cssIndex];
            $.stylesheet(css.tagName, css.cssKey, css.cssValue);
            style += $.stylesheet(css.tagName).rules()[0].cssText;
        }
    }
    //append the closing style tag, completing the style element.
    style += "</style>";

    //Add the invisible temporary saving element that holds the data while it is being cleaned
    $("body").prepend($("<span id='saving_temp' style='display:none'></span>"));

    //Get a ref to the temp element
    var div = $("#saving_temp");

    //Get the HTML and convert it back to unicode
    div.html(_m.util.converBackToUnicode(($(".doc")[0]).outerHTML));

    //Remove any classes and elements we don't want to end up in the finished product
    div.find(".notSave,iframe").remove();
    div.find(".justSelected,.justExtended").removeClass("justSelected").removeClass("justExtended");
    div.find(".markup[randomID]").removeAttr("randomID");

    //Concatentate, the head, style, bodyhead, content, bodytail and tail to create the saveContent
    var saveContent = head + style + bodyhead + $("#saving_temp").html() + bodytail + tail;

    //Log the data to be saved for debugging purposes
    console.log($("#saving_temp").html());

    //Call the saveFile function with the following parameters
    saveFile(filename, saveContent, function(fileEntry) {
        $("#saving_temp").remove();
        $('#export').attr("href", fileEntry.toURL()).attr("download", $('.doc').attr('filename') + "_layout.html");
        $('#export')[0].click();
    });
};

/**
 * Saves a file using the FileSystem. It requests write access and in return Gets
 * a fileEntry (basically a filePointer) that can be written to. Once we have that object
 * we write all the data that needs to be saved to there and call the callback function once the
 * writing of data is complete
 *
 * @for IO
 * @method saveFile
 * @param  {String} filename     the name of the file we want to create
 * @param  {String} text         the textdata of the file we want to create
 * @param  {Function} _fn        the callback function, called once the file has been written
 * @param  {Function} errorHandler A custom errorHandler, does not need to specified, can also be kept default
 */
var saveFile = function(filename, text, _fn, errorHandler) {
    //If an errorHandler has not explicitly set, use the default one
    if (errorHandler === null) {
        errorHandler = ERROR_HANDLER;
    }
    //Saying we're started in the console, for debugging purposes
    console.log("exporting start");

    //Request access to the fileSystem
    window.webkitRequestFileSystem(window.TEMPORARY, 1024 * 1024, function(fs) {
        //Logging that we got this far, debugging purposes
        console.log("exporting file");

        //With access to the fileSystem, say we want to create a file
        fs.root.getFile(filename, {
            create: true
        }, function(fileEntry) {
            //At this point we have a fileEntry object, which is a filepointer

            // fileEntry.remove(function(){}, function(){});
            //We then create a writer that can write to this fileEntry
            fileEntry.createWriter(function(fileWriter) {
                //This blob variable holds the text we want to save
                var blob = new Blob([text], {
                    type: 'text/plain'
                });

                //once we're done with saving, call the callback function
                fileWriter.addEventListener("writeend", function() {
                    if (_fn) {
                        _fn(fileEntry);
                    }
                }, false);

                //Start writing the blob data to the file
                fileWriter.write(blob);

                //ALL the error handlers in case something goes to hell
            }, ERROR_HANDLER);
        }, ERROR_HANDLER);
    }, ERROR_HANDLER);
};

/**
 * Removes the specified file from the fileSystem.
 *
 * @for IO
 * @method removeFile
 * @param  {String} filename     the name of the file we want to remove
 * @param  {Function} _fn          the callback function, called once the file has successfully been removed
 * @param  {Function} errorHandler the errorHandler, does not need to be defined, can fallback to default handler
 */
var removeFile = function(filename, _fn, errorHandler) {
    //If the error handler has not explicitly been set, use the default errorHandler
    if (errorHandler === null) {
        errorHandler = ERROR_HANDLER;
    }

    //Request access to the fileSystem.
    window.webkitRequestFileSystem(window.TEMPORARY, 1024 * 1024, function(fs) {
        fs.root.getFile(filename, {
            create: false
        }, function(fileEntry) {
            //Once we have a FilePoitner to work with, we remove it and call the callBack function
            fileEntry.remove(function() {
                if (_fn) {
                    _fn(fileEntry);
                }
            }, errorHandler);

        }, errorHandler);
    }, errorHandler);
};

/**
 * Defines the `markus.io` object that can be accessed globally. Uses some functions that have
 * been defined in the io.js anonymous namespace, but also defines some functions in the object
 * creation itself.
 *
 * @class IO
 * @constructor
 */
_m.io = {
    removeFile: removeFile,
    saveFile: saveFile,
    /**
     * Defines the readFile function. This allows you to read a file specified by the fileName
     * and calls the callback on succes
     *
     * @method readFile
     * @param  {String} _file        the fileName as a String
     * @param  {Function} _fn          The callBack function
     * @param  {Function} errorHandler custom error handler
     */
    readFile: function(_file, _fn, errorHandler) {
        //If the errorHnadler has not been explicitly set, use the default one
        if (errorHandler === null) {
            errorHandler = ERROR_HANDLER;
        }

        //Define the onInitFS function, use right below this function
        function onInitFs(fs) {
            fs.root.getFile(_file, {}, function(fileEntry) {
                // fs.root.getFile(file+'.html', {}, function(fileEntry) {
                // Get a File object representing the file,
                // then use FileReader to read its contents.
                fileEntry.file(function(_file) {
                    //Defines a new FileReader.
                    var reader = new FileReader();
                    //Once we are finished loading call the callback with the resulting data
                    //and start parsing the CSS from the css TagAttr
                    reader.onloadend = ( function(file) {
                        return function(evt) {
                            if (_fn) {
                                _fn(this.result, file);
                                loadCSSFromCSS_TagAtt();
                            }
                        };
                    } )(_file);

                    //Start reading the file
                    reader.readAsText(_file);
                }, errorHandler);

            }, errorHandler);

        }
        //Request acces to the fileSystem to kick the whole process off
        window.webkitRequestFileSystem(window.TEMPORARY, 1024 * 1024, onInitFs, errorHandler);
    },

    /**
     * Exports a MARKUS save file and automatically saves it
     *
     * @method exportSave
     * @param  {String} filename the fileName of the file you download
     */
    exportSave: function(filename) {
        //Set the tag attribute to the JSON version of markus.tag
        $(".doc").attr("tag", _m.util.convertToEscapeUnicode($.toJSON(_m.tag)));
        //Remove the tagCSS attribute
        $(".doc").removeAttr("tagCSS");

        //First removes the file and then saves the file, triggering an autoDownload
        removeFile(filename + ".html", function() {
            saveSave(filename + ".html", function(fileEntry) {
                autoDownload(fileEntry, "_markus.html");
            });
        }, function() {
            saveSave(filename + ".html", function(fileEntry) {
                autoDownload(fileEntry, "_markus.html");
            });
        });
    },

    /**
     * Exports a TEI save file of the document and automatically saves it
     *
     * @method exportTEI
     * @param  {String} filename the fileName of the file you download
     */
    exportTEI: function(filename) {
        //Set the tag attribute to the JSON version of markus.tag
        $(".doc").attr("tag", _m.util.convertToEscapeUnicode($.toJSON(_m.tag)));
        //Remove the tagCSS attribute
        $(".doc").removeAttr("tagCSS");

        //First removes the file and then saves the file, triggering an autoDownload
        removeFile(filename + "_tei.xml", function() {
            saveTEI(filename + "_tei.xml");
        }, function() {
            saveTEI(filename + "_tei.xml");
        });
    },

    /**
     * Exports a HTML save of the document and its layout and automatically saves it
     *
     * @method exportHTML
     * @param  {String} filename the fileName of the file you download
     */
    exportHTML: function(filename) {
        //Set the tag attribute to the JSON version of markus.tag
        $(".doc").attr("tag", _m.util.convertToEscapeUnicode($.toJSON(_m.tag)));
        //Remove the tagCSS attribute
        $(".doc").removeAttr("tagCSS");

        //First removes the file and then saves the file, triggering an autoDownload
        removeFile(filename + "_layout.html", function() {
            saveHTML(filename + "_layout.html");
        }, function() {
            saveHTML(filename + "_layout.html");
        });
    },

    /**
     * A simple basic save to the normal MARKUS format. Cleans the data, processes it
     * for download and then automatically downloads it.
     *
     * @method save
     * @param  {String} filename The filename of the new file we want to create
     * @param  {Function} _fn     The callback function called uppon completion
     */
    save: function(filename, _fn) {
        //If there are any defined tags in `markus.tag`
        if (Object.keys(_m.tag).length > 0) {
            //Add them to the tag attribute of the doc
            $(".doc").attr("tag", _m.util.convertToEscapeUnicode($.toJSON(_m.tag)));
        }
        //Remove the tagCSS attribute
        $(".doc").removeAttr("tagCSS");

        //After that it removes the file and then uses the basic save
        removeFile(filename + ".html", function() {
            saveSave(filename + ".html", _fn);
        }, function() {
            saveSave(filename + ".html", _fn);
        });
    },

    //Define these markus.io functions by pointing to the functions that have
    //been defined in the anonymous namespace above
    newTagCSS: newTagCSS,
    removeTagCSS: removeTagCSS,
    updateSwitchers: updateSwitchers,
    updateManualPopover: updateManualPopover,
    loadCSSFromCSS_TagAtt: loadCSSFromCSS_TagAtt
};
} )(markus);

/**
 * Global method that registers the Global Tag Management UI, it also takes care of all its
 * event handlers etc.
 *
 * @for Global
 * @method registeTagManageUI
 */
var registeTagManageUI = function() {
    //When we show the manageTag Modal
    $("#manageTagModal").on("show.bs.modal", function() {
        var tbody = $("#manageTagModal .modal-body .manageTagTable");
        tbody.empty();

        //For each of the color-switcher-class we append a table
        $("#buttonsRow [color-switcher-class]").each(function() {
            var fix = ($(this).attr("data-markus-default") == "true");
            var tr = $("<tr class='tagSetting' color-switcher-class='" + $(this).attr("color-switcher-class") + "'' />");
            tr.append("<td><input data-markus-action='shortcut' type='checkbox' " + ($(this).is(":visible") ? "checked" : "") + " /></td>");
            tr.append($("<td/>").append($(this).clone().show()));
            tr.append($("<td><input type='text' class='form-control' data-markus-value='tagName' value='" + $(this).attr("color-switcher-class") + "' " + ((fix ? "disabled" : "") + "></input>") + "</td>"));
            tr.append($("<td><input type='text' class='form-control' data-markus-value='color-switcher-class' value='" + $(this).text() + "''></input></td>"));
            tr.append($("<td><input data-markus-action='remove' type='checkbox' /></td>"));
            tbody.append(tr);
        });
    });

    //When you click the setManageTagBtn
    $("#setManageTagBtn").on("click", function() {
        $("#manageTagModal .modal-body .tagSetting").each(function() {
            //For each of the tagSettings
            var tagSwitcher = $(this).attr("color-switcher-class");
            var fix = ($("#buttonsRow [color-switcher-class='" + tagSwitcher + "']").attr("data-markus-default") == "true");
            var buttonName = $(this).find("input.form-control[data-markus-value='color-switcher-class']").val();
            var tagName = markus.util.chineseToPingYin($(this).find("input.form-control[data-markus-value='tagName']").val()).trim();

            //If the buttonName is just a space, assure that it remains that
            if (buttonName.trim() === "") {
                buttonName = "　";
            }

            //If the tagName and tagSwitcher are not the same
            if (tagName != tagSwitcher) {
                //Get the color from the markus.tag object
                var tagColor = markus.tag[tagSwitcher].color;
                //Remove the CSS and re-add it back
                markus.io.removeTagCSS(tagSwitcher);
                markus.io.newTagCSS(tagName, tagColor);

                //Remove and add the necessary classes
                $("#buttonsRow [color-switcher-class='" + tagSwitcher + "']").removeClass(tagSwitcher).addClass(tagName).attr("color-switcher-class", tagName);
                $("#manualPopover .singleTagContent button." + tagSwitcher).removeClass(tagSwitcher).addClass(tagName).attr("_type", tagName);
                $(".doc ." + tagSwitcher).removeClass(tagSwitcher).addClass(tagName).attr("type", tagName);
            }

            //Define the markus.tag[tagSwitcher] object if it not already has been set
            markus.tag[tagSwitcher] = markus.tag[tagSwitcher] || {
                color: tagColor,
                buttonName: buttonName,
                status: ""
            };

            //set the buttonName
            markus.tag[tagSwitcher].buttonName = buttonName;

            //Set the visible status and act upon it
            var visble = markus.tag[tagSwitcher]["visible"] = $(this).find("input[data-markus-action='shortcut']").is(":checked");

            //If it is visible, show the buttons and set the text for the elements
            if (visble) {
                $("#buttonsRow [color-switcher-class='" + tagSwitcher + "']").show();
                $("#manualPopover .singleTagContent button." + tagSwitcher).show();
                $("#buttonsRow [color-switcher-class='" + tagSwitcher + "']").text(buttonName);
                $("#manualPopover .singleTagContent button." + tagSwitcher).text(buttonName);

            } else {
              //If it is not visible, hide the buttons and manualPopover and text for the elements
                $("#buttonsRow [color-switcher-class='" + tagSwitcher + "']").text(buttonName);
                $("#manualPopover .singleTagContent button." + tagSwitcher).text(buttonName);
                $("#buttonsRow [color-switcher-class='" + tagSwitcher + "']").hide();
                $("#manualPopover .singleTagContent button." + tagSwitcher).hide();

            }
            if ($(this).find("input[data-markus-action='remove']").is(":checked")) {

                if (fix) {
                    $("#buttonsRow [color-switcher-class='" + tagSwitcher + "']").hide();
                    $("#manualPopover .singleTagContent button." + tagSwitcher).hide();

                } else {
                    $("#buttonsRow [color-switcher-class='" + tagSwitcher + "']").remove();
                    $("#manualPopover .singleTagContent button." + tagSwitcher).remove();
                }
                $(".doc ." + tagSwitcher).contents().unwrap();
                markus.io.removeTagCSS(tagSwitcher);
            }
        });
        $(".doc").attr("tag", JSON.stringify(markus.tag));
        // $(".doc").attr("tagCSS", "");
        $("#manageTagModal").modal('toggle');
    });

    //Defines what happens when you click the new Tag button
    $("#newTagBtn").on("click", function() {
        //Create a tagname by changing Chinese to pingYin
        var tagName = markus.util.chineseToPingYin($("#manageTagModal .newTagTable [data-markus-value='tagName']").val()).trim();
        //The unchanged version of the tagName
        var buttonName = $("#manageTagModal .newTagTable [data-markus-value='color-switcher-class']").val();
        //If the buttonName is only a space, make sure it remains only a space
        if (buttonName.trim() === "") {
            buttonName = "　";
        }

        //Find the tagColor we want to use
        var tagColor = $("#manageTagModal .tagColor").val();

        //Define the newTag CSS by calling the function to do just that
        markus.io.newTagCSS(tagName, buttonName, tagColor);

        //Reset the newTagTable now that the newTag has been registered
        $("#manageTagModal .newTagTable [data-markus-value='tagName']").val("");
        $("#manageTagModal .newTagTable [data-markus-value='color-switcher-class']").val("");

        //Update the switchers and manualPopover to show the newly added tag
        markus.io.updateSwitchers();
        markus.io.updateManualPopover();

        //Toggle the manageModal
        $("#manageTagModal").modal("toggle");
    });
};
;/**
 * manualMarkup.js base file.
 * @module io.js
 */

 /**
 The class that holds the variables and functions created in the namespace of this file.
 The constrcutor of this object is only called once, because it is an anonymous function.

 @class manualMarkup.js_anonymous
 @constructor
 @param {Object}  _m a reference to the Markus Configuration Object is passed
 **/
( function(_m) {

    /**Holds the tag toggle*/
    var tagToggle = null;

    /**
     * This function cleans the class attribute of the element this is called on.
     *
     * @method registMakupAction
     * @param {Span} justAdd  one of the spans that still has the justAdd class
     */
    var registMakupAction = function() {
        var _class = $(this).attr("class");
        $(this).attr("class", _class.trim());
    }

    /**
     * Called when we have a new type of markup to save. We set the classes on
     * the corresponding element, and fadeout the `singleTagContent` css class
     * elements. Also shows the `.search` element at the end of the function.
     *
     * @method newtypeSave
     */
    var newtypeSave = function() {
        //get a reference to the just clicked markup instance
        var clickedMarkup = _m.popup.clickedMarkup;
        //remove the ``.justAdd` class if it already was added. From all the elements
        //that have it right now, including just clicked markup
        $(".justAdd").removeClass("justAdd");

        //If there is an element within #manualPopover that has the switch element
        //with a defined color
        if ($("#manualPopover").find(".switch:not(.noColor)").length > 0) {
            //remove class: `justselected`,
            //add class: `justAdd`, `markup`, `manual`, `unsolved`
            //From the clicked markup we get in the beginning of the function
            $(clickedMarkup).removeClass("justSelected").addClass("justAdd").addClass("markup").addClass("manual").addClass("unsolved");

            //Get the type of the manualPopover switch.
            var type = $("#manualPopover").find(".switch:not(.noColor)").attr("_type");

            //Do based on type
            switch (type) {
                case "fullName":
                case "partialName":
                    //In case it's a name, we add that is has no CBDBID.
                    $(clickedMarkup).addClass(type).addClass("noCBDBID").attr("type", type).attr("cbdbid", "");
                    break;
                default:
                    //Else we just add the type attribute as the type.
                    $(clickedMarkup).addClass(type).attr("type", type);
            }
        }

        //We fadeout the singleTagContent element
        $("#manualPopover").find(".singleTagContent").fadeOut();
        //For each of the just added elements we call the `registMakupAction`,
        //This function just cleans the class assignement.
        $(".doc").find("span.justAdd").each(registMakupAction);
        //We find the search element and show it
        $("#manualPopover").find(".search").show();

        // $("#manualPopover").find(".glyphicon-search").click();
    }

    /**
     * Function called when either `applyAllBtn` or `removeAllBtn` has fired
     * and event and we want to process it. This just removes the `fired` class
     * from both of those buttons if present.
     *
     * @method initialRemoveModal
     */
    var initialRemoveModal = function() {
        $("#applyAllBtn").removeClass("fired");
        $("#removeAllBtn").removeClass("fired");
    }

    /**
     * Shows and or hides the `#removeModal` and the `#removeAll` and `#applyAll` buttons
     *
     * @method updateRemoveModal
     */
    var updateRemoveModal = function() {
        // console.log($("#removeModal").find(".well").length);

        //Swtich based on the amount of wells found within the #removeModal element
        switch ($("#removeModal").find(".well").length) {
            case 0:
                //If none were found, hide the modal
                $("#removeModal").modal("hide");
                break;
            case 1:
                //If there was one, hide both the removeAll and applyAll button.
                $("#removeAllBtn").hide();
                $("#applyAllBtn").hide();
                break;
            default:
                //If there are a different amount of wells

                //Set the styling of the first well with the sameTags class
                $("#removeModal").find(".sameTags .well:first").css({
                    "border-width": "2px",
                    "border-color": "#8D8C8C",
                    "background-color": "#D8D5D5"
                });

                //If the removeAllBtn has the fired class, show it, else fadeOut
                if (!$("#removeAllBtn").hasClass("fired")) {
                    $("#removeAllBtn").show();
                } else {
                    $("#removeAllBtn").fadeOut();
                }


                //If the applyAllBtn has the fired class, show it, else fadeOut
                if (!$("#applyAllBtn").hasClass("fired")) {
                    $("#applyAllBtn").show();
                } else {
                    $("#applyAllBtn").fadeOut();
                }

        }

    }

    /**
     * Shows the just created markup instance. Sets the classes of the markup element.
     *
     * @method showManualMarkup
     */
    var showManualMarkup = function() {
        //Get a reference to the clicked Markup
        var clickedMarkup = _m.popup.clickedMarkup;

        //Hide the popOver class objects
        $(".popover").hide();

        //Get the text of the clickedMarkup.
        var text = $(clickedMarkup).text();

        //If there is no text in the clickedMarkup this is not a valid state,
        //return without doing anything.
        if (text.trim().length == 0) {
            return;
        }

        //get the html from the document and then set it back to the html
        //that we jus retrieved. Unsure what this does.
        var html = $(".doc").html();
        $(".doc").html(html);


        //Wrap all of the elements in the document that have a nodeType of 3
        //and a nodevalue that matches the clickedMarkups textValue in a
        //`<wrap>` element.
        $(".doc").find("*").contents().filter(function() {
            return this.nodeType === 3 && this.nodeValue.indexOf(text) > -1;
        }).wrap("<wrap>");
        // console.log(items);

        //Replace all wrap elements in this function
        $("wrap").replaceWith(function() {
            //Replaces all instances with an `span` element with the `justExtended`, `unsolved` and `markup` classes.
            return $("<wrap>" + $(this).text().replace(new RegExp(text, 'g'), "<span class='justExtended unsolved markup'>" + text + "</span>") + "</wrap>");
        });
        //Unwraps the contents, removes the wrapping elements now that the changes have been made.
        $("wrap").contents().unwrap();

        //If there are elements with the `justAdd` class
        if ($(".doc").find(".justAdd").length > 0) {
            $(".doc").find(".justAdd .justExtended").contents().unwrap();
            clickedMarkup = $(".doc").find(".justAdd");
        } else if ($(".doc").find(".justSelected .justExtended").length > 0) {
            //Else we unwrap the `.justSelected` contents
            clickedMarkup = $(".doc").find(".justSelected .justExtended");
            $(".doc").find(".justSelected").contents().unwrap();
        }

        //Get the extended spans with parents that have the same text as the child element
        var extended = $("span.justExtended").filter(function() {
            var parent = $(this).parent();
            if (parent.hasClass("markup")) {
                return $(parent).text() == $(this).text();
            }
            return false;

        });

        //Unwrap all those identical elements
        extended.contents().unwrap();

        //Then we show all the same markups
        _m.popup.showSameMarkup();
    }


    /**
     * Defines the `markus.manualMarkup` object that can be accessed globally. Uses some functions that have
     * been defined in the manualMarkup.js anonymous namespace, but also defines some functions in the object
     * creation itself.
     *
     * @class ManualMarkup
     * @constructor
     */
    _m.manualMarkup = {
        /**
         * Handles the registering of manual markup. Handles the necessary registering
         * of event handlers and takes care of the selection from the document.
         *
         * @method registManualMarkup
         * @param  {Object} editable An editable object
         */
        registManualMarkup: function(editable) {
            var editable = editable || false;
            rangy.init();


            if (rangy.supported && rangy.modules.CssClassApplier && rangy.modules.CssClassApplier.supported) {
                tagToggle = rangy.createCssClassApplier("justSelected", {
                    tagNames: ["markup"]
                });
            } else {
                alert("error");
            }

            //Click handler for the document
            $(document).on("click", ".doc", function() {
                //We get a selection from the rangy plugin
                var sel = rangy.getSelection();

                // var selContainerNode = null;
                // If there is even a selection
                if (sel.rangeCount > 0) {
                    // console.log(sel);
                    tagToggle.applyToSelection();
                    // console.log($(".justSelected"));
                    // We set all the initial stats of the `#manualPopover` element
                    var popover = $("#manualPopover");
                    popover.find(".tagText").hide();
                    popover.find(".typePopoverContent").hide();
                    popover.find(".singleTagContent").show();

                    popover.find(".glyphicon-collapse-down").show();
                    popover.find(".expand").show();
                    popover.find(".typePopoverContent .btn.switch").addClass("noColor");
                    popover.find(".typePopoverContent .glyphicon-floppy-disk").addClass("disabled");

                    //If a valid editable was passed we show the `typePopoverContent`
                    if (editable) {
                        popover.find(".typePopoverContent").show();
                    }

                    //If there are `.justSelected` spans
                    var term = $(".justSelected");
                    if (term.length > 0) {
                        term = $(".justSelected")[0];
                        var offset = $(term).offset();
                        //we set a ref to the just clicked term
                        _m.popup.clickedMarkup = $(term);

                        //We show the popover next to the just clicked term
                        $(popover).show().offset({
                            top: $(term).offset().top + $(term).height() / 2 - $(popover).outerHeight() / 2,
                            left: $(term).offset().left + $(term).outerWidth() + 11
                        });
                    }

                }
            });

            //Registers some clickhandlers, some of which call back to the anonymous namespace used above
            $("#manualPopover .glyphicon-book").on("click", _m.popup.searchMarkup);
            $("#manualPopover .glyphicon-floppy-disk").on("click", newtypeSave);
            $("#manualPopover .glyphicon-search").on("click", showManualMarkup);
            // $("#manualPopover .glyphicon-trash").on("click", function() {
            //     alert("trash");

            // });

            //When we cloick on the `.typePopoverContent`
            $("#manualPopover .typePopoverContent").on("click", "button.switch", function() {
                // if($(this).attr("markupType")){
                $("#manualPopover .glyphicon-floppy-disk").removeClass("disabled");
                $("#manualPopover .typePopoverContent button.switch").addClass("noColor");
                $(this).removeClass("noColor");
                // $(".doc").find("."+$(this).attr("markupType")).toggleClass("noColor");
                // }
            });

            //If we click on the `glyphicon-collapse-down`
            $("#manualPopover").find(".glyphicon-collapse-down").on("click", function() {
                var expand = $(this).parent();
                expand.hide();
                $(expand).parent().find(".search").hide();
                $(expand).parent().find(".typePopoverContent").fadeIn();
            });

            //When the `initial` or `update` event are passed
            $("#removeModal").on("update", updateRemoveModal);
            $("#removeModal").on("initial", initialRemoveModal);

            //When the removeModal hides
            $("#removeModal").on("hide.bs.modal", function() {
                // var parent = $(".justSelected,.justExtended").parent();
                $(".justSelected,.justExtended").contents().unwrap();

            });
        }

    };


} )(markus);
;/**
 * markupPopup.js base files
 * @module markupPopup.js
 */

/*
  Note: cbdbIdSameTagSave not work
*/

 /**
 The class that holds the variables and functions created in the namespace of this file.
 The constrcutor of this object is only called once, because it is an anonymous function.

 @class markupPopup.js_anonymous
 @constructor
 @param {Object}  _m a reference to the Markus Configuration Object is passed
 **/
( function(_m) {

/**
 * The removeSameTags array. Internal use by functions
 * @type {Array}
 */
var removeSameTags = [];
/**
 * If the markup is editable.
 *
 * @type {Boolean}
 */
var markupEditable = false;

/**
 * Removes the markup that was clicked on. Contained within `markus.popup.clickedMarkup`.
 * It hides the popOver and unwraps the removeTarget. (This basically removes the .markup
 * element around the tag)
 *
 * @method removeMarkup
 */
var removeMarkup = function() {
    var removeTarget = _m.popup.clickedMarkup;
    $(".popover").hide();
    removeTarget.contents().unwrap();

};

var showSameMarkup = function() {
    var clickedMarkup = _m.popup.clickedMarkup;
    $(".popover").hide();
    $("#removeModal").find(".tagText").text($(clickedMarkup).text());
    var onScreen = [],
        sameMarkup = [],
        markupText = $(clickedMarkup).text(),
        _htmlTemp = "";

    removeSameTags = getSameTags(markupText);

    if ($(clickedMarkup).hasClass("justAdd")) {
        for (var key in removeSameTags) {
            if ($(removeSameTags[key].tag).hasClass("justAdd")) {
                _htmlTemp = getSameTagHTML(key) + _htmlTemp;
            }
        }
        for (var key in removeSameTags) {
            if (!$(removeSameTags[key].tag).hasClass("justAdd")) {
                _htmlTemp += getSameTagHTML(key);

            }
        }

    } else {
        for (var key in removeSameTags) {
            if (removeSameTags[key].tag == clickedMarkup[0]) {
                _htmlTemp = getSameTagHTML(key) + _htmlTemp;
            }
        }
        for (var key in removeSameTags) {
            if (removeSameTags[key].tag != clickedMarkup[0]) {
                _htmlTemp += getSameTagHTML(key);
            }

        }

    }

    $("#removeModal").trigger("initial");
    $("#removeModal").find(".sameTags").contents().remove();
    $("#removeModal").find(".sameTags").html(_htmlTemp);

    if (markupEditable) {
        $("#removeModal button.switch").on("click", function() {
            $(this).toggleClass("noColor");
        });

        $("#removeModal .glyphicon-ok-circle").on("click", function() {
            $(this).toggleClass("btn-link").toggleClass("btn-success").toggleClass("glyphicon-lock");
            if ($(this).hasClass("btn-link")) {
                $(this).parent().find(".glyphicon-trash").removeClass("disabled");
            } else {
                $(this).parent().find(".glyphicon-trash").addClass("disabled");
            }

        });

        $("#removeModal .glyphicon-trash").on("click", function() {
            if (!$(this).hasClass("disabled")) {
                removeSameTag($(this).attr("key"));
            }
        });

        $("#removeModal .glyphicon-trash").on("mouseenter", function() {
            if (!$(this).hasClass("disabled")) {
                $(this).removeClass("btn-link").addClass("btn-danger");
            }
        });

        $("#removeModal .glyphicon-trash").on("mouseleave", function() {
            $(this).removeClass("btn-danger").addClass("btn-link");
        });

        $("#removeModal .cbdbIdSameTagSave").on("click", function() {
            if (!$(this).hasClass("disabled")) {
                cbdbIdSameTagSave($(this).attr("key"));
            }
        });
        $("#removeModal .IdSameTagSave").on("click", function() {
            if (!$(this).hasClass("disabled")) {
                // console.log("click: " + $(this).attr("key"));
                IdSameTagSave($(this).attr("key"));
            // cbdbIdSameTagSave($(this).attr("key"));
            }
        });

    } else {
        $("#removeModal .col-xs-1").hide();
        $("#removeModal .col-xs-10").addClass("col-xs-12").removeClass("col-xs-10");
        $("#removeModal .cbdbIds").hide();

        $("#removeModal .modal-footer").hide();

    }



    $("#removeModal").trigger("update");

    $("#removeModal").modal('show');
    $("#removeModal").on("shown.bs.modal", function() {
        $(this).find(".well").each(function() {
            var maxHeight = 0;
            $(this).find("div,span").each(function() {
                maxHeight = Math.max(maxHeight, $(this).height());
            });
            $(this).find("div:not(.btn,.fixHeight)").height(maxHeight);
            // $(this).find(".fixHeight").removeClass("fixHeight");
            $(this).find(".row:not(.all)").each(function() {
                var parent = $(this).parent();
                $(this).offset({
                    top: $(parent).offset().top + $(parent).outerHeight() / 2 - $(this).outerHeight() / 2
                });
            });
        });
    });
};

var getSameTags = function(markupText) {
    var sameTags = [];
    var serialCount = 0;
    $(".doc").find(".markup").each(function() {

        if ($(this).text() == markupText && $($(this).parent()).text() != markupText) {
            $(this).attr("randomID", serialCount++);

            var contents = $(this).parent().contents();

            // var contents = $(".doc").contents();

            var index = contents.index(this),
                onScreen = false,
                headIndex = index - 1,
                tailIndex = index + 1,
                frontText = "",
                endText = "";


            var sameTagChild = $(this).find(".markup").filter(function() {
                return $(this).text() == markupText;
            });

            // console.log(getSurroundText(this));


            var splittedHTML = $(".doc").html().split($(this)[0].outerHTML);



            splittedHTML[0] = splittedHTML[0].replace(/(<([^>]+)>)/ig, "");
            splittedHTML[1] = splittedHTML[1].replace(/(<([^>]+)>)/ig, "");


            frontText = splittedHTML[0].substr(splittedHTML[0].length - 20);
            endText = splittedHTML[1].substr(0, 20);

            sameTags.push({
                tag: this,
                onScreen: $(this).visible(true),
                html: (frontText + $(this)[0].outerHTML + endText),
                sameTagChild: sameTagChild
            });
        // sameTags.push({tag:this,onScreen:$(this).visible(true),html:(frontText +$(this).clone().wrap('<p>').parent().html()+endText),sameTagChild:sameTagChild});
        }
    });
    return sameTags;
};

var getSameTagHTML = function(key) {
    /*
      <button type="button" class="btn btn-xs btn-danger switch fullName" >姓名</button>
              <button type="button" class="btn btn-xs btn-warning switch partialName" >別名</button>
              <button type="button" class="btn btn-xs btn-success switch nianhao" >年號</button>
              <button type="button" class="btn btn-xs btn-primary switch placeName" >地名</button>
              <button type="button" class="btn btn-xs btn-info switch officialTitle" >官職</button>
              <a onclick="typeSave()" class="glyphicon glyphicon-floppy-disk"></a>
      */
    var child = removeSameTags[key].sameTagChild;
    var childHTML = "";
    var cbdbIdsHTML = "";
    for (var i = 0; i < child.length; i++) {
        var type = $(child[i]).attr("type");
        // console.log(type);
        switch (type) {
        case "fullName":
            childHTML += '<button type="button" class="btn btn-xs btn-danger switch fullName" >姓名</button>';
            break;
        case "partialName":
            childHTML += '<button type="button" class="btn btn-xs btn-warning switch partialName" >別名</button>';
            break;
        case "nianhao":
            childHTML += '<button type="button" class="btn btn-xs btn-success switch nianhao" >年號</button>';
            break;
        case "placeName":
            childHTML += '<button type="button" class="btn btn-xs btn-primary switch placeName" >地名</button>';
            break;
        case "officialTitle":
            childHTML += '<button type="button" class="btn btn-xs btn-info switch officialTitle" >官職</button>';
            break;
        case "timePeriod":
            childHTML += '<button type="button" class="btn btn-xs btn-info switch timePeriod" >時間</button>';
            break;
        default:
            childHTML += '<button type="button" class="btn btn-xs btn-info switch ' + type + '" >' + type + '</button>';
            break;
        }
    }

    if (childHTML.length > 0) {
        var type = $(removeSameTags[key].tag).attr("type");
        switch (type) {
        case "fullName":
            childHTML += '<button type="button" class="btn btn-xs btn-danger switch fullName" >姓名</button>';
            break;
        case "partialName":
            childHTML += '<button type="button" class="btn btn-xs btn-warning switch partialName" >別名</button>';
            break;
        case "nianhao":
            childHTML += '<button type="button" class="btn btn-xs btn-success switch nianhao" >年號</button>';
            break;
        case "placeName":
            childHTML += '<button type="button" class="btn btn-xs btn-primary switch placeName" >地名</button>';
            break;
        case "officialTitle":
            childHTML += '<button type="button" class="btn btn-xs btn-info switch officialTitle" >官職</button>';
            break;
        case "timePeriod":
            childHTML += '<button type="button" class="btn btn-xs btn-info switch timePeriod" >時間</button>';
            break;
        default:
            childHTML += '<button type="button" class="btn btn-xs btn-info switch ' + type + '" >' + type + '</button>';
        }
        childHTML += '<div key="' + key + '" class="btn btn-xs btn-link glyphicon glyphicon-floppy-disk sameTagTypeSave"></div>';
    } else {
        var type = $(removeSameTags[key].tag).attr("type");
        if (type == "fullName" || type == "partialName") {
            var inputColorClass = (type == "fullName") ? "has-error" : "has-warning";
            var btnColorClass = (type == "fullName") ? "btn-danger" : "btn-warning";
            // if (!$(removeSameTags[key].tag).attr("cbdbid")) {
            //     $(removeSameTags[key].tag).attr("cbdbid", "");
            // }



            var cbdbIds = markus.util.converBackToUnicode($(removeSameTags[key].tag).attr("cbdbid")).split("|");
            for (var index in cbdbIds) {
                if (cbdbIds[index].length > 0) {
                    cbdbIdsHTML += "<button type='button' class='btn btn-xs " + btnColorClass + " switch'>" + cbdbIds[index] + "</button> ";
                }

            }
            cbdbIdsHTML += '<input style="height:22px;width:100px;display:inline-block;margin-bottom: 1px;"type="text" class="form-control input-sm ' + inputColorClass + '" placeholder="Cbdb ID"></input> <a key="' + key + '" class="glyphicon glyphicon-floppy-disk cbdbIdSameTagSave"></a>';
        } else {
            if ($(removeSameTags[key].tag).attr(type + "_id")) {
                var Ids = markus.util.converBackToUnicode($(removeSameTags[key].tag).attr(type + "_id")).split("|");
                for (var index in Ids) {
                    if (Ids[index].length > 0) {
                        cbdbIdsHTML += "<button type='button' class='btn btn-xs " + type + " switch'>" + Ids[index] + "</button> ";
                    }

                }
                cbdbIdsHTML += '<input style="height:22px;width:100px;display:inline-block;margin-bottom: 1px;"type="text" class="form-control input-sm ' + type + '" placeholder="ID"></input> <a key="' + key + '" class="glyphicon glyphicon-floppy-disk IdSameTagSave"></a>';
            }
        }



    }

    return '<div class="row well well-sm" key="' + key + '"><div><div class="col-xs-10">' + removeSameTags[key].html + '</div><div class="col-xs-1" style="padding-left:0px;">' + childHTML + '</div><div class="col-xs-1" style="padding-right:0px"><div class="row"><span class="btn btn-link glyphicon glyphicon-trash" key="' + key + '"></span> | <span class="btn btn-link glyphicon glyphicon-ok-circle"></span></div></div></div><div class="row all well-sm fixHeight cbdbIds"><div class="col-xs-12 fixHeight">' + cbdbIdsHTML + '</div></div></div>';
};

/**
 * Searches trough the appropriate dictionary for the markup the user just clicked
 * on. Depending on the dictionary type the response varies. Most of the time the
 * web-dictionary is just clicked (to show it), but sometimes an `<input>` on the
 * web-dictionary can be set to the value of the clicked markup (or in case of the CBDB to
 * a CBDBID)
 *
 * @method searchMarkup
 */
var searchMarkup = function() {
    //Get a reference to the clicked markup instance
    var clickedMarkup = _m.popup.clickedMarkup;
    //Hide the comment field, show the assist
    $("#comment").hide();
    $("#assist").show();
    //Set the web-dictionary-input to the value of the clickedMarkup text and trigger a change event on the input.
    $(".web-dictionary-input").val(clickedMarkup.text()).trigger("change");

    //If it is a fullName or partialName
    if (clickedMarkup.hasClass("fullName") || clickedMarkup.hasClass("partialName")) {
      //get the cbdbid attr.
        var cbdbid = clickedMarkup.attr("cbdbid");
        if (cbdbid) { //if it exists, but length = 0, get the id from the clickedMarkup text
            if (cbdbid.trim().length == 0) {
                cbdbid = $(clickedMarkup).text();
            }
        } else {
          //get the id from the clickedMarkup text
            cbdbid = $(clickedMarkup).text();
        }
        //Open the cbdb web-dictionary, set its input to the cbdbid obtained and trigger an update
        $(".web-dictionary[web-dictionary-name='cbdb'] .web-dictionary-input").val(cbdbid).trigger("change");
        //   searchCBDB(clickedMarkup.text(), clickedMarkup.attr("cbdbid"));
        //   showCBDBRef();
        //Trigger a click to show the web-dictionary
        $(".web-dictionary-tab[web-dictionary-name='cbdb']").trigger("click");
    } else if (clickedMarkup.hasClass("placeName")) {
        //If it is a placeName, show the appropriate web-dictionary by triggering a click
        $(".web-dictionary-tab[web-dictionary-name='chgis']").trigger("click");
    //   showCHGISRef();
    } else if (clickedMarkup.hasClass("ddbcGlossaries")) {
        //If it is a ddbcGlossaries, show the appropriate web-dictionary by triggering a click
        $(".web-dictionary-tab[web-dictionary-name='ddbcGlossaries']").trigger("click");
    //   showCHGISRef();
    } else if (clickedMarkup.hasClass("ddbcPerson")) {
          //If it is a ddbcPerson, show the appropriate web-dictionary by triggering a click,
          //but first set the input to the 'ddbcperson_id' attr of the clicked markup
        $(".web-dictionary[web-dictionary-name='ddbcPerson'] .web-dictionary-input").val(clickedMarkup.attr("ddbcperson_id")).trigger("change");
        $(".web-dictionary-tab[web-dictionary-name='ddbcPerson']").trigger("click");
    //   showCHGISRef();
    } else {
      //Else just show the zdic web-dictionary.
        $(".web-dictionary-tab[web-dictionary-name='zdic']").trigger("click");
    //   showZDICRef();
    }

      // _m.popup.clickedMarkup = clickedMarkup = null;
};

/**
 * Defines what happens when you click the `#removeAllBtn` button. When you click this button
 * all the `.glyphicon-trash` elements that are not disabled are clicked (removing the instance with it).
 *
 * @method removeAllSameTag
 */
var removeAllSameTag = function() {
    $("#removeAllBtn").addClass("fired");
    $("#removeModal").find(".glyphicon-trash:not(.disabled)").each(function() {
        $(this).click();
    });
    //Remove all occurences of the justAdd and justExtended class across the doc
    $(".justAdd").removeClass("justAdd");
    $(".justExtended").removeClass("justExtended");
    //Trigger an update on the removeModal
    $("#removeModal").trigger("update");
};

/**
 * Defines what happens when you click the `#applyAll` button. When you click this button
 * the contents of the first well are copied across all the other wells. This is to unify contents
 * of the markup.
 *
 * @method applyAll
 */
var applyAll = function() {
    $("#applyAllBtn").addClass("fired");
    // $("#removeAllBtn").addClass("fired");

    //the key of the first well
    var sourcekey = $("#removeModal").find(".well:first").attr("key");
    //The first tag within the first well
    var firstTag = $("#removeModal").find(".well:first .markup:first");

    // var child = $(removeSameTags[sourcekey].sameTagChild;
    // The HTML content of the tag
    var tagContent = getTheTagContent(getTheOuterTag(removeSameTags[sourcekey].tag));

    //We get all the unlocked keys..
    var keys = getAllunLockedKeys();
    //and for each of them
    for (var index in keys) {
        var key = keys[index];
        //If this is not the same key as the first well
        if (sourcekey != key) {
            // console.log(key);
            var tag = removeSameTags[key].tag;
            // console.log(tag);
            var outerTag = getTheOuterTag(tag);

            //We replace the tag contents to be the same as the tagContent from the source (well:first)
            removeSameTags[key].tag = replaceTag(outerTag, tagContent);
            //Get a ref to the well we're working on right now
            var well = $("#removeModal").find(".well[key='" + key + "']");

            //Wrap the first markup in a paragraph and return its parent
            var wrap = well.find(".markup:first").wrap("<p>").parent();
            //empty the wrap (remove the first markup?)
            wrap.contents().remove();
            //Set them to be identical to this first tag
            wrap.append($(firstTag).clone().removeClass("selected"));
            //Unwrap the wrap again, the wrap was just to allow for easy jquery editing
            wrap.contents().unwrap();

            // well.find(".markup:first").outerHTML = $(firstTag).clone().removeClass("selected").outerHTML;

            //Trigger a click on the ok circle
            $(well).find(".glyphicon-ok-circle").click();
            //Hiden the elements that have any of the following classes
            $(well).find(".cbdbIds,.glyphicon-floppy-disk,.switch").hide();


        }
    }


    //Remove all occurences in the whole document of the 'justAdded' and 'justExtended' class.
    $(".justAdd").removeClass("justAdd");
    $(".justExtended").removeClass("justExtended");
    //Then trigger an update on the removeModal
    $("#removeModal").trigger("update");
};

/**
 * Initializes the removeModal by removing the `.fired` class, if it was present
 * to begin with. This makes sure they actually show up as the `updateRemoveModal` function
 * tells the buttons to fade once they have the `.fired` class.
 *
 * @method initialRemoveModal
 */
var initialRemoveModal = function() {
    $("#applyAllBtn").removeClass("fired");
    $("#removeAllBtn").removeClass("fired");
};

/**
 * Called to update the `#removeModal`. Used to change the contents of this modal
 * depending on its contents.
 *
 * @method updateRemoveModal
 */
var updateRemoveModal = function() {

    // console.log($("#removeModal").find(".well").length);
    // Do something based on the amount of `well` class items found in the removeModal
    switch ($("#removeModal").find(".well").length) {
      //If there are none left, hide the modal
    case 0:
        $("#removeModal").modal("hide");
        break;
    case 1:
      //If there is only one left, hide the 'removeAll' and 'applyAll' buttons
        $("#removeAllBtn").hide();
        $("#applyAllBtn").hide();
        break;
    default:
      //Set the first well with the sameTags class to have the following CSS
        $("#removeModal").find(".sameTags .well:first").css({
            "border-width": "2px",
            "border-color": "#8D8C8C",
            "background-color": "#D8D5D5"
        });

        //If the removeAllButton has the fired class, fade it out, else show it
        if (!$("#removeAllBtn").hasClass("fired")) {
            $("#removeAllBtn").show();
        } else {
            $("#removeAllBtn").fadeOut();
        }
        //If the applyAllBtn has the fired class, fade it out, else show it
        if (!$("#applyAllBtn").hasClass("fired")) {
            $("#applyAllBtn").show();
        } else {
            $("#applyAllBtn").fadeOut();
        }

    }

};

/**
 * Returns an array of all the key attributes of the `glyphicon-trash` icons that do not
 * have a `disabled` class
 *
 * @method getAllunLockedKeys
 * @return {Array} Returns the unlocked keys.
 */
var getAllunLockedKeys = function() {
    var keys = [];
    $("#removeModal").find(".glyphicon-trash:not(.disabled)").each(function() {
        keys.push($(this).attr("key"));
    });
    // console.log(keys);
    return keys;
};

/**
 * Returns the surroundign element of the provided tag. This is done by going up
 * the DOM hierarchy untill we find a parent that does not have the same textcontent
 * as the child. This means we have the first parent that also has different children.
 *
 * @method getTheOuterTag
 * @param  {Element} tag the tag we want to now the containing tag of
 * @return {Element}     the containing tag of the tag we provided
 */
var getTheOuterTag = function(tag) {
    var parent = $(tag).parent();
    while ($(tag).text() == $(parent).text()) {
        parent = $(parent).parent();
        tag = parent;
    }
    return tag;
};

/**
 * Replaces the provided tag with the provided HTML string content.
 *
 * @method replaceTag
 * @param  {Element} tag     The element to replace
 * @param  {String} content  The string that represents the HTML data to replace the tag with
 * @return {Element}         The element after it has been replaced.
 */
var replaceTag = function(tag, content) {

    // var wrapper = $(tag).wrap('<p>').parent();
    // if (tag){
    //   $(tag).remove();
    // }
    // wrapper.html(content);
    // wrapper.find(".markup").each(registMakupAction);
    // tag = wrapper.find(".markup:first");
    // wrapper.contents().unwrap();

    if (tag) {
        $(tag)[0].outerHTML = content;
    // console.log(replaceTag);
    }

    return tag;
};

/**
 * Returns the html content (including itself) of the provided tag. Removes the
 * `selected` class before returning the HTML data string.
 *
 * @method getTheTagContent
 * @param  {Element} tag the tag we want to get the content of
 * @return {String}      the HTML content represented as a string
 */
var getTheTagContent = function(tag) {
    var clone = $(tag).clone();
    // var _html = $(clone).removeClass("selected").wrap('<p>').parent().html();
    var _html = $(clone).removeClass("selected")[0].outerHTML;
    clone.remove();
    return _html;
};

/**
 * Defines what happens when you click the applyAll button. Sets the cbdbId of
 * all the markups contained to the cbdbId of the clickedMarkup
 *
 * @method applyAllSameType
 */
var applyAllSameType = function() {
    /* find the clicked in removeSameTags Id. , well, need to change the removeSameTags to others
       or plan another 'types' storing schema
    */
    //The markup we just clicked
    var clickedMarkup = _m.popup.clickedMarkup;

    //Add the fired class to make it fadeOut afterwards (because ofthe removeModalUpdate)
    $("#applyAllBtn").addClass("fired");

    //Get the cbdbId from the clickedMarkup as an attribute.
    var cbdbId = markus.util.converBackToUnicode($(clickedMarkup).attr("cbdbid"));
    $("#removeModal").find(".row").each(function() {
        //All of the elements that do not have a disabled but do have a glyphicon-trash
        if ($(this).has(".glyphicon-trash:not(.disabled)").length) {
          //Get all of the .cbdbIds and update them and click the link within them.
            $(this).find(".cbdbIds").each(function() {
                $(this).find("input").val(cbdbId).parent().find("a").click();
            });
        }
    });

    //Trigger an update on the removeModal
    $("#removeModal").trigger("update");

};

/**
 * Removes the sametag (spans multiple DOM levels if they are only-child) specified
 * by the provided key. Updates the `#removeModal` afterwards;
 *
 * @param  {String} key the key of the entry we want to delete
 */
var removeSameTag = function(key) {
    //Get the tag of the key we want to remove
    var tag = removeSameTags[key].tag;
    //Get the parent of the tag
    var parent = $(tag).parent();
    //Get the markup child of the tag
    var child = $(tag).find(".markup");
    //Get the text of the tag
    var text = $(tag).text();

    //Add the remove class
    $(tag).addClass("remove");

    //If the parent text is identical to the tag text(the parent has no other children) remove it
    if ($(parent).text() == text) {
        $(parent).addClass("remove");
    }
    //If the child text is identical to the tag-text (the child is only child) remove it.
    if ($(child).text() == text) {
        $(child).addClass("remove");
    }

    //Find all the instances of the .remove class and unwrap their contents (removing the container markup)
    $(".doc").find(".remove").contents().unwrap();

    //We find the well for the key that was provided and fade it out
    $("#removeModal").find(".well[key='" + key + "']").fadeOut({
        complete: function() {
          //Once the fadeout is complete,  remove the well and trigger an update on the
          //#removeModal
            $("#removeModal").find(".well[key='" + key + "']").remove();
            $("#removeModal").trigger("update");
        }
    });

    //Since this key is now removed, remove it from the removeSameTags array
    removeSameTags[key] = null;
};

/**
 * Defines the behaviour when you click the `.sameTagTypeSave` element.
 *
 * @method sameTagTypeSave
 */
var sameTagTypeSave = function() {
  //Gets the key attribute from the clicked element
    var key = $(this).attr("key");
    // console.log(removeSameTags);

    var child = removeSameTags[key].sameTagChild;
    child.push(removeSameTags[key].tag);

    //Find all the markup in a well
    var wellMarkup = $("#removeModal").find(".well[key='" + key + "']").find(".markup");

    //For each of the buttons within the specified well that has a switch and noColor class
    $("#removeModal").find(".well[key='" + key + "']").find("button.switch.noColor").each(function() {
        //If the clicked element has a class identical to the type of the markup in the well
        for (var i = 0, j = wellMarkup.length; i < j; i++) {
            if ($(this).hasClass($(wellMarkup[i]).attr("type"))) {
                $(wellMarkup[i]).addClass("remove");
            }
        }
        //For each of the children that have the same type, remove them too
        for (var i = 0, j = child.length; i < j; i++) {
            if ($(this).hasClass($(child[i]).attr("type"))) {
                $(child[i]).addClass("remove");
            }
        }
        //Then remove the element we just clicked
        $(this).remove();
    });

    //Remove same tags
    if ($(removeSameTags[key].tag).hasClass("remove")) {
        // console.log("removeSameTag remove hooked tag");
        for (var i = 0; i < removeSameTags[key].sameTagChild.length && $(removeSameTags[key].tag).hasClass("remove"); i++) {
            removeSameTags[key].tag = removeSameTags[key].sameTagChild[i];
        }
    }

    //Go up through the DOM untill we find the actual parent
    var _parent = $(removeSameTags[key].tag).parent();
    while ($(_parent).text() == $(removeSameTags[key].tag).text() && !$(_parent).hasClass("remove")) {
        removeSameTags[key].tag = _parent;
        _parent = $(removeSameTags[key].tag).parent();
    }

    //Where the markup needs to be unwrapped, do so
    $(".doc").find(".markup.remove").contents().unwrap();

    //Also reflect these changes in the removeModal
    $("#removeModal").find(".well[key='" + key + "']").find(".markup.remove").contents().unwrap();

    //If there are no more buttonswitches
    if ($("#removeModal").find(".well[key='" + key + "']").find("button.switch").length === 0) {
        $("#removeModal").find(".well[key='" + key + "']").fadeOut({
          //We fadeout this well if there are no more buttons in it
            complete: function() {
              //Once its done, hide the removeModal and remove the specific well
                $("#removeModal").find(".well[key='" + key + "']").remove();
                if ($("#removeModal").find(".well").length === 0) {
                    $("#removeModal").modal("hide");
                }
            }
        });
    } else {
      //Get the row specified by the provided key
        var row = $("#removeModal").find(".well[key='" + key + "'] .row");
        //Disable the trash icon and make it a bnt-link instead of btn danger
        $(row).find(".glyphicon-trash").addClass("disabled").addClass("btn-link").removeClass("btn-danger");
        //Find the ok icon and remove the btnLink, and make it a btn-succes, also add glyphicon-lock and disabled
        $(row).find(".glyphicon-ok-circle").removeClass("btn-link").addClass("btn-success").addClass("glyphicon-lock").addClass("disabled");
    }
};

/**
 * Hide the popPover on save of this type.
 *
 * @method typeSave
 */
var typeSave = function() {
  //Get a reference to the cliked markup
    var clickedMarkup = _m.popup.clickedMarkup;

    //Get its parent
    var _parent = $(clickedMarkup).parent();
    // console.log("typeSave");

    //For each button with a noColor class
    $("#typePopoverContent").find("button.noColor").each(function() {
        if (_parent) {
          //If the parent has a type set identical to the class of this (Backwards compatibility?), unwrap it
            if ($(this).hasClass($(_parent).attr("type"))) {
                $(_parent).contents().unwrap();
                _parent = null;
            }
        }
        //If the clickedMarkup has a type attribute identical to this button, then unwrap it
        if (clickedMarkup) {
            if ($(this).hasClass($(clickedMarkup).attr("type"))) {
                $(clickedMarkup).contents().unwrap();
                clickedMarkup = null;
            }
        }

    });
    //Hide the popOver, now that we have done all this;
    $(".popover").hide();

    //null the reference
    _m.popup.clickedMarkup = clickedMarkup = null;
};

/**
 * Saves the cbdbid that the user has typed into the input field onto the HTML element
 * either as cbdbid attribute or `type`_id attribute.
 *
 * @method cbdbIdSave
 */
var cbdbIdSave = function() {
    //Get a reference to the markup that was just clicked
    var clickedMarkup = _m.popup.clickedMarkup;
    if (clickedMarkup === null) {
        return;
        //If it was not set, go back.
    }

    //Get cbdbid attribute or similar attribute if not present
    var ids = $(clickedMarkup).attr("cbdbid") || $(clickedMarkup).attr($(clickedMarkup).attr("type") + "_id") || "";

    // console.log(ids);
    var cbdbIds = [];
    if (ids.length > 0) {
      //Convert to unicode and split it on the '|'
        cbdbIds = markus.util.converBackToUnicode(ids).split("|");
    }
    // console.log(cbdbIds);
    // The value from the `<input>` in the cbdbIdPopoverContent
    var cbdbInputVal = $("#cbdbIdPopoverContent").find("input").val();

    /*
        // orginial design is just for CBDB, and CBDBID only contains digital. Now it will disable to allow other type of characters for different IDs

        Todo : ids format need to be designed to filter different kinds of id format


        if (cbdbInputVal.match(/\d+/g)) {
            clickedMarkup.attr("cbdbid", cbdbInputVal);
            clickedMarkup.removeClass("moreThanOneId").removeClass("noCBDBID");
        }

    */

    // if (cbdbInputVal.match(/\d+/g)) {
    //     clickedMarkup.attr("cbdbid", cbdbInputVal);
    //     clickedMarkup.removeClass("moreThanOneId").removeClass("noCBDBID");
    // }

    // console.log(clickedMarkup.attr(clickedMarkup.attr("type") + "_id"));
    // console.log(clickedMarkup);

    //Remove any whitespace from the inputvalue
    cbdbInputVal = cbdbInputVal.replace(/\s+/g);
    //If there is actually a value left and there are no more '|''s
    if (cbdbInputVal.length > 0 && cbdbInputVal.indexOf("|") == -1) {
      //If we have a type_id attribute
        if ($(clickedMarkup).attr($(clickedMarkup).attr("type") + "_id") !== undefined) {
          //Set that attribute to the input value
            clickedMarkup.attr(clickedMarkup.attr("type") + "_id", markus.util.convertToEscapeUnicode(cbdbInputVal));
        } else {
          //Else set the cbdbid attribute to the input value
            clickedMarkup.attr("cbdbid", markus.util.convertToEscapeUnicode(cbdbInputVal));
        }
        //Remove moreThanOneId and noCBDBID, since the cbdbid is now set
        clickedMarkup.removeClass("moreThanOneId").removeClass("noCBDBID");
    } else {
        $("#cbdbIdPopoverContent").find("button.noColor").each(function() {
          //For each of the buttonsNoColor,
            var cbdb = $(this).text();
            //remove this cbdbid from the list of ids
            cbdbIds.splice(cbdbIds.indexOf(cbdb), 1);
        });
        //If there is still stuff left in the input box
        if (cbdbInputVal.length > 0) {
            cbdbIds = cbdbInputVal.split("|");
        }
        //Based onthe length of id's possible, display or not display the moreThanOneId and noCBDBID class
        switch (cbdbIds.length) {
        case 0:
            clickedMarkup.removeClass("moreThanOneId").addClass("noCBDBID");
            break;
        case 1:
            clickedMarkup.removeClass("moreThanOneId").removeClass("noCBDBID");
            break;
        default:
            clickedMarkup.addClass("moreThanOneId").removeClass("noCBDBID");
        }

        //If we have a attribute of type_id, set it to the joined remains of cbdbIds array
        if (clickedMarkup.attr(clickedMarkup.attr("type") + "_id") !== undefined) {
            clickedMarkup.attr(clickedMarkup.attr("type") + "_id", markus.util.convertToEscapeUnicode(cbdbIds.join("|")));
        } else {
          //Set the cbdbid attribute to the joined remains of the cbdbIds array
            clickedMarkup.attr("cbdbid", markus.util.convertToEscapeUnicode(cbdbIds.join("|")));
        }
    }
    //Clear the input textfield after use
    $("#cbdbIdPopoverContent").find("input").val("");
    //Hide the popOver
    $(".popover").hide();
    //Null the clicked reference
    _m.popup.clickedMarkup = clickedMarkup = null;
};

/**
 * Saves the id the user has manually typed into an input field to override the
 * cbdbId of that element.
 *
 * @param  {String} key the key of the well we're working with
 */
var cbdbIdSameTagSave = function(key) {
    var tag = removeSameTags[key].tag;
    // console.log("cbdbIdSameTagSave");
    var cbdbIds = $(tag).attr("cbdbid").split("|");

    //Get the input value of the input on the .cbdbIds within the specified well
    var cbdbInputVal = $("#removeModal").find(".well[key='" + key + "']").find(".cbdbIds input").val();

    //Make sure it is only digits
    if (cbdbInputVal.match(/\d+/g)) {
      //Set the cbdbid attribute to the input value
        $(tag).attr("cbdbid", cbdbInputVal);
        //Remove the classes displaying ambiguity (moreThanOneId and noCBDBID)
        $(tag).removeClass("moreThanOneId").removeClass("noCBDBID");

        //For each of switchButtons in this well, only display color if the input value is identical to the text on the button
        $("#removeModal").find(".well[key='" + key + "']").find(".cbdbIds button.switch").each(function() {
            if ($(this).text() == cbdbInputVal) {
                $(this).removeClass("noColor");
            } else {
                $(this).addClass("noColor");
            }
        });

    } else {//If it is not only digits
      //For all of the .cbdbIds with a button.switch.noColor
        $("#removeModal").find(".well[key='" + key + "']").find(".cbdbIds button.switch.noColor").each(function() {
            var cbdb = $(this).text();
            //remove any mathces from the cbdbIds array
            cbdbIds.splice(cbdbIds.indexOf(cbdb), 1);
        });
        //Switch classes of the tag, based on the amount of cbdbIds. Display (or not) moreThanOneId and noCBDBID
        switch (cbdbIds.length) {
        case 0:
            $(tag).removeClass("moreThanOneId").addClass("noCBDBID");
            break;
        case 1:
            $(tag).removeClass("moreThanOneId").removeClass("noCBDBID");
            break;
        default:
            $(tag).addClass("moreThanOneId").removeClass("noCBDBID");
        }
        //Set the attribute cbdbid of the tag to the joined remains of the cbdbIds array
        $(tag).attr("cbdbid", cbdbIds.join("|"));
    }

    //Reference the row in this well specified by the provided key
    var row = $("#removeModal").find(".well[key='" + key + "'] .row");
    //Disable the trash icon, make it a link instead of a danger button
    $(row).find(".glyphicon-trash").addClass("disabled").addClass("btn-link").removeClass("btn-danger");
    //Lock the ok-circle, make it a success button instead of link
    $(row).find(".glyphicon-ok-circle").addClass("glyphicon-lock").removeClass("btn-link").addClass("btn-success");
    // $("#removeModal").find(".well[key='"+key+"']").find(".cbdbids input").val("");
    // $(".popover").hide();
    // clickedMarkup = null;
};

/*
Todo : merge cbdbIdSameTagSave
*/

/**
 * Manually save an ID and overwrite all other tags in the file using it too.
 *
 * @method IdSameTagSave
 * @param  {String} key the key that was clicked
 */
var IdSameTagSave = function(key) {
    var tag = removeSameTags[key].tag;
    // console.log("IdSameTagSave");
    var ids = $(tag).attr($(tag).attr("type") + "_id").split("|");

    //Get the input from the well. Remove all whitespace from the value
    var inputVal = $("#removeModal").find(".well[key='" + key + "']").find("input" + "." + $(tag).attr("type")).val().replace(/\s+/g);

    //If there was actually an input value left after the cleaning of the data
    if (inputVal.length > 0) {
      //Set the id to the input val (manually entering id)
        $(tag).attr($(tag).attr("type") + "_id", inputVal);
        //Remove the moreThanOneId and noCBDBID classes
        $(tag).removeClass("moreThanOneId").removeClass("noCBDBID");

        //Remove or add the noColor class if the text of the button matches the inputValue
        $("#removeModal").find(".well[key='" + key + "']").find("button.switch" + "." + $(tag).attr("type")).each(function() {
            if ($(this).text() == inputVal) {
                $(this).removeClass("noColor");
            } else {
                $(this).addClass("noColor");
            }

        });

    } else {
      //Within the well defined by the provided key, for each button swithc with nocolor and matching type, save all the id's
        $("#removeModal").find(".well[key='" + key + "']").find("button.switch.noColor" + "." + $(tag).attr("type")).each(function() {
            var id = $(this).text();
            ids.splice(ids.indexOf(id), 1);
        });
        switch (ids.length) {
          //Based on the amount of id's remove the moreThanOneId class and add the noCBDBID class
        case 0:
            $(tag).removeClass("moreThanOneId").addClass("noCBDBID");
            break;
        case 1:
            $(tag).removeClass("moreThanOneId").removeClass("noCBDBID");
            break;
        default:
            $(tag).addClass("moreThanOneId").removeClass("noCBDBID");
        }
        $(tag).attr($(tag).attr("type") + "_id", ids.join("|"));
    }

    //Find the row contained within the well
    var row = $("#removeModal").find(".well[key='" + key + "'] .row");
    //Disable the glyphicon-trash and make it a .btn-link class with .btn-danger
    $(row).find(".glyphicon-trash").addClass("disabled").addClass("btn-link").removeClass("btn-danger");
    //Lock the glyphicon-ok-circle by showing the glyphicon-lock and removing the btn-link class, make it a btn-succes
    $(row).find(".glyphicon-ok-circle").addClass("glyphicon-lock").removeClass("btn-link").addClass("btn-success");

    // $("#removeModal").find(".well[key='"+key+"']").find(".cbdbids input").val("");
    // $(".popover").hide();
    // clickedMarkup = null;
};

/**
 * The class that represents `markus.popup`. This holds all the necessary handlers
 * and data for the popOver functionality.
 *
 * @class Popup
 */
_m.popup = {
    /**
     * Holds a reference to the popOver element used to make a floating window
     * appear with markup controls in it (remove, search etc.);
     *
     * @type {Element}
     */
    popover: null,
    /**
     * Holds a reference to the markup that was just clicked. May be null!
     *
     * @type {Markup}
     */
    clickedMarkup: null,

    /**
     * Function is defined in the markupPopup.js_anonymous class. Function is exposed
     * using this class (`markus.popup`);
     *
     * @method searchMarkup
     * @type {Function}
     */
    searchMarkup: searchMarkup,

    /**
     * Function is defined in the markupPopup.js_anonymous class. Function is exposed
     * using this class (`markus.popup`);
     *
     * @method showSameMarkup
     * @type {Function}
     */
    showSameMarkup: showSameMarkup,

    /**
     * Registers the popover used for the markup instances. Creates handlers for
     * click, mouseenter and update for the buttons and other content.
     *
     * @method registMarkupPopup
     * @param  {boolean} editable if this markup is editable
     */
    registMarkupPopup: function(editable) {
      //register the popOver used as the popover, i.e. the #popOver element
        _m.popup.registPopover($("#popover"));
        markupEditable = editable || false;

        //When a click happens on the .doc in the document (I.e. unfocus / blur)
        $(document).on("click", ".doc", function() {
            //Unselect any previously selected markups
            $(".selected").removeClass("selected");
            //Hide the popover
            $(".popover").hide();
            //No popup is clicked right now
            _m.popup.clickedMarkup = null;

            //Remove the justSelected class from any markup
            $(".justSelected.markup").removeClass("justSelected");
            // $(".justExtended").contents().unwrap();
            // And unwrap its contents
            $(".justSelected,.justExtended").contents().unwrap();
        });

        //Register the click handlers for the icons in the markup popover
        $("#cbdbIdPopoverContent a").on("click", cbdbIdSave);
        $("#typePopoverContent a").on("click", typeSave);
        $("#popover .search a").on("click", showSameMarkup);
        $("#popover .trash a").on("click", removeMarkup);
        $("#popover .glyphicon-book").on("click", searchMarkup);

        //When you click a markup, you are forwarded to the markupClicked function (click handler)
        $(document).on("click", ".doc .markup", _m.popup.markupClicked);
        //When you click the sameTagTypeSave you are forwarded to the sameTagTypeSave function (click handler)
        $(document).on("click", ".sameTagTypeSave", sameTagTypeSave);

        //If you hit the .switch element in the typePopoverContent, the .noColor class is toggled
        $(document).on("click", "#typePopoverContent .switch", function() {
            $(this).toggleClass("noColor");
        });

        //When you click the removeAllBtn, the removeAllSameTag function is called
        $("#removeAllBtn").on("click", removeAllSameTag);

        //When you click the applyAllBtn, the applyAll function is called
        $("#applyAllBtn").on("click", applyAll);

        //When you hit the cancel button, the #removeModal is hidden
        $("#cancelBtn").on("click", function() {
            $("#removeModal").modal("hide");
        });

        // console.log(_m.util.urlParam('file'));

        //If an update event is request, forward it to the update function (updateremoveModal)
        $("#removeModal").on("update", updateRemoveModal);
        //If we fire the initial event (re-initialzing the modal), forward it to the initialRemoveModal function
        $("#removeModal").on("initial", initialRemoveModal);

        //When the modal is hidden unwrap the justSelected and justExtended contents
        $("#removeModal").on("hide.bs.modal", function() {
            // var parent = $(".justSelected,.justExtended").parent();
            $(".justSelected,.justExtended").contents().unwrap();

        });
    },

    /**
     * Sets the reference variable `markus.popup.popover` to the provided element.
     *
     * @method registPopover
     * @param  {Element} popover the element that is used as the popover
     */
    registPopover: function(popover) {
        this.popover = popover;
    },

    /**
     * Defines what happens when you click on an instance of `.markup`. This shows the popOver,
     * registers it, and fills the popOver with content depending on the type of markup, and
     * the markup content. Also checks for nested multitags.
     *
     * @param  {Event} event the mouseEvent. Just passed to stop it from bubbling
     */
    markupClicked: function(event) {
      //Stop the event from bubbling
        event.stopPropagation();

        //Hide the popOver if it is currently showing
        $(".popover").hide();

        //Get a reference to the object as a JQuery HTML element
        var obj = $(this);
        //Get its parent, offset and text
        var _parent = obj.parent(),
            offset = obj.offset(),
            tagText = obj.text();

        //Find any other .markup tags that have the same text, but not the same parent
        var otherTags = $(".doc").find(".markup").filter(function(index) {
            return (tagText == $(this).text()) && $(obj).parent() != this && obj != this;
        });

        // unselect any previously selected tag
        $(".markup.selected").removeClass("selected");
        // set the currently selected tag as selected
        obj.addClass("selected");
        // console.log($(this));

        //Update the clickedMarkup reference to the just clicked object
        _m.popup.clickedMarkup = $(this);

        //Get the popover and hide the .tagText
        var popover = _m.popup.popover;
        popover.find(".tagText").hide();

        /*
          start
          Nested multi tags detect and show popup
        */

       //Hide the typePopoverContent element, and if it has any buttons, remove their 'noColor' class and disabled attribute
        var typePopoverContent = popover.find("#typePopoverContent");
        typePopoverContent.hide();
        typePopoverContent.find("button").removeClass("noColor").removeAttr("disabled").hide();

        //While the parent text matches the clicked text and the parent is of class markup, we are the sameTag
        var sameTag = false;
        while (_parent.is(".markup") && _parent.text() == tagText) {
            sameTag = true;
            //Show it in the typePopoverContent
            typePopoverContent.find("." + $(_parent).attr("type")).show();
            //Go up through the DOM hierarchy
            _parent = _parent.parent();
        }

        //If they are a nested multitag
        if (sameTag) {
            //Show all of the type of this and show them
            typePopoverContent.find("." + $(this).attr("type")).show();
            typePopoverContent.show();
        } else {
            //Find all of this, set their disabled attribute and show them
            typePopoverContent.find("." + $(this).attr("type")).attr("disabled", "disabled").show();
            typePopoverContent.show();
        }

        /*
          end nested multi tags
        */

       //If we can edit the markup
        if (markupEditable) {
            //If there are other tags
            if (otherTags.length > 0) {
              //Show the search and trash icons
                popover.find(".search").show();
                popover.find(".trash").show();
            } else {
              //if there are no other tags, only show the trash icon, but not the search since there is nothing to find
                popover.find(".trash").show();
                popover.find(".search").hide();
            }
        } else {
          //If we can't edit the markup
            if (otherTags.length > 0) {
              //Only allow searching if there are other tags
                popover.find(".search").show();
                popover.find(".trash").hide();
            } else {
              //If there are no other tags there is nothing meaningful you can do right now
                popover.find(".trash").hide();
                popover.find(".search").hide();
            }
        }

        //Now show the popOVer and set its position
        popover.show().offset({
            top: offset.top + $(this).height() / 2 - popover.outerHeight() / 2,
            left: offset.left + obj.outerWidth() + 11
        });

        //If we have a class of fullName or partialName, or a set type_id attribute
        if (obj.hasClass("fullName") || obj.hasClass("partialName") || (obj.hasClass("markup") && (obj.attr(obj.attr("type") + "_id") !== null))) {
          //set the color class according to the obj class
            var colorClass = "";
            if (obj.hasClass("fullName")) {
                colorClass = "btn-danger";
                $("#cbdbIdPopoverContent").addClass("has-error").removeClass("has-warning");
            } else {
                colorClass = "btn-warning";
                $("#cbdbIdPopoverContent").addClass("has-warning").removeClass("has-error");
            }

            //If we are allowed to edit the markup, we get a ref to the cbdbIdPopover
            if (markupEditable) {
                var cbdbIdPopover = $("#cbdbIdPopover");
                var cbdbIdPopoverContent = cbdbIdPopover.find("#cbdbIdPopoverContent");
                var cbdbIdsHTML = "";
                //We remove all the buttons from it, effectively resetting it
                cbdbIdPopoverContent.find("button").remove();

                //If the object is a name of some kind
                if (obj.hasClass("fullName") || obj.hasClass("partialName")) {
                  //If the object has no attribute of cbdbid, set it to an empty string
                    if (!obj.attr("cbdbid")) {
                        obj.attr("cbdbid", "");
                    }
                    //Get the cbdbid attribute and split it into its parts
                    if ($(this).attr("cbdbid")) {
                        var cbdbids = $(this).attr("cbdbid").split("|");

                        //For each of them create a new button
                        for (var i = 0; i < cbdbids.length; i++) {
                            if (cbdbids[i].length > 0) {
                                cbdbIdsHTML += "<button class='btn " + colorClass + " btn-xs' style='margin-bottom: 1px;'>" + cbdbids[i] + "</button> ";
                            }
                        }
                    }
                } else {
                  //If it doesn;t have this attribute, set it
                    if (!$(this).attr($(this).attr("type") + "_id")) {
                        $(this).attr($(this).attr("type") + "_id", "");
                    }
                    //Split it using the '|' as delimiter.
                    var ids = $(this).attr($(this).attr("type") + "_id").split("|");
                    if (ids.length > 0) {
                      //For each of the  id's add a button
                        for (var i = 0; i < ids.length; i++) {
                            if (ids[i].length > 0) {
                                cbdbIdsHTML += "<button class='btn " + obj.attr("type") + " btn-xs' style='margin-bottom: 1px;'>" + markus.util.converBackToUnicode(ids[i]) + "</button> ";
                            }
                        }
                        //Set the placeHolder attribute of the input to 'ID';
                        cbdbIdPopover.find("#cbdbIdPopoverContent input").attr("placeholder", "ID");
                    // $("#cbdbIdPopoverContent a").on("click", function() {
                    //     console.log("clicked")
                    // });
                    }
                }
                // console.log('$(this).attr("cbdbid").split("|")');
                // console.log(cbdbIdsHTML);
                //Prepend the html to the cbdbIdPopoverContent
                $(cbdbIdPopoverContent).prepend(cbdbIdsHTML);

                //If the popOver is out of the viewable screen on the top
                if (offset.top - cbdbIdPopover.outerHeight() - 11 < $(".doc").offset().top) {
                  //Change its attachment to the object
                    cbdbIdPopover.addClass("bottom").removeClass("top").show().offset({
                        top: offset.top + obj.outerHeight() + 11,
                        left: offset.left + obj.outerWidth() / 2 - cbdbIdPopover.outerWidth() / 2
                    });
                } else {
                  //If its viewable, standard attachment to the clickedMarkup
                    cbdbIdPopover.addClass("top").removeClass("bottom").show().offset({
                        top: offset.top - cbdbIdPopover.outerHeight() - 11,
                        left: offset.left + obj.outerWidth() / 2 - cbdbIdPopover.outerWidth() / 2
                    });
                }

                //Any button will toggle this clicked objects 'noColor' class
                $(cbdbIdPopoverContent).find("button").on("click", function() {

                    $(this).toggleClass("noColor");
                });
            }
        }
    }
};
} )(markus);
;/**
 * navbar.js base file.
 * @module navbar.js
 */

 /**
 The class that holds the variables and functions created in the namespace of this file.
 The constrcutor of this object is only called once, because it is an anonymous function.

 @class navbar.js_anonymous
 @constructor
 @param {Object}  _m a reference to the Markus Configuration Object is passed
 **/
( function(_m) {

//Creates the NavBar object
_m.navbar = {};

/**
 * Defines the loadNavBar function that will later be register to the `markus.navbar.register`
 * functions.
 *
 * This function defines all the behaviour of the navBar and the registers all the listeners to
 * the NavBar UI objects.
 *
 * Please read through the source to understand what the actual navBar buttons do.
 *
 * @method loadNavBar
 */
var loadNavBar = function() {
    //Sets a cookie for the language
    var lang = $.cookie('lang') || "";
    $.cookie('lang', lang, {
        path: '/'
    });

    //Loads the navBar.html template for the appropriate language
    $("#navbar").load("navbar" + lang + ".html", {}, function() {
        $("#exportNav").show();

        //Loads the user profile info as JSON
        $.getJSON("/auth/profile_info", function(result) {
            if (result["name"]) {
                //Loads the userSection for that lanugage and sets the info according to the userName
                $.get("userSection" + lang + ".html", function(data) {
                    $("#userSection").html(data);
                    $("#userName").text(result["name"]);
                });
            }

        //Below is what happens if you're not logged in, you will lose all current data
        }).fail(function() {
            //If you click on the userSection but are not logged in, you will get prompted
            //If you're sure of your decisions in live that lead you to this point in time.
            $("#userSection a").on("click", function(event) {
                var lang = $.cookie('lang') || "";
                var decision = false;

                //Base the prompt upon the language cookie
                if (lang == "_zhtw") {
                    decision = confirm("登入後將會失去現在(Guest)的工作進度，你要先暫停登入以進行輸出'MARKUS存檔'嗎 ?");
                } else {
                    decision = confirm("You will lose all current data upon login. Do you want to stay on this page and export your current file first? You can proceed to login upon exporting your file.");
                }

                //If we cancel the button click, stop the event from propagating
                if (decision == true) {
                    event.preventDefault();
                    event.stopPropagation();
                } else {
                  //DO NOTHING
                }
            });
        });

        //Defines what happens when you click on the SaveButton
        $('#save').on("click", function() {

            //Get the fileName
            var fileName = $('.doc').attr('filename');

            //Set the saveIcon to the floppy-save icon from glyphicon
            $('#save .glyphicon-floppy-disk').removeClass("glyphicon-floppy-disk").addClass("glyphicon-floppy-save");
            $('#save .glyphicon-floppy-saved').removeClass("glyphicon-floppy-saved").addClass("glyphicon-floppy-save");

            //Call the save function with the following funciton as a second parameters
            markus.io.save(fileName, function(fileEntry) {
                //Once it has been saved, remove the save glyphicon to give feedback on the saving
                $('#save .glyphicon-floppy-save').removeClass("glyphicon-floppy-save").addClass("glyphicon-floppy-saved");

                //load the user profile info as JSON
                $.getJSON("/auth/profile_info", function(result) {
                    if (result["name"]) {
                        var data = new FormData();

                        //The upload file form
                        fileEntry.file(function(_file) {
                            data.append("upload", _file);
                            console.log(_file);

                            //If the file size is >4Mb you cannot store it, you get a request if you want to export the save.
                            if (_file.size > 4194304) {
                                var lang = $.cookie('lang') || "";
                                var decision = false;
                                if (lang == "_zhtw") {
                                    decision = confirm("MARKUS 暫不接受儲存大於 4 M 的檔案到伺服器, 要以 '輸出 MARKUS File' 保存於本機嗎 ?");
                                } else {
                                    decision = confirm("MARKUS cannot store files larger than 4MB. Do you want to export your current file to the MARKUS format? You can then still open it in MARKUS from your desktop.");
                                }

                                //If they want to export the save, the save is exported.
                                if (decision == true) {
                                    markus.io.exportSave($('.doc').attr('filename'));
                                }
                            //If the file is a decent size (<4Mb)
                            } else {
                                //Save the DATA using a AJAX POST request
                                $.ajax({
                                    url: '/auth/upload',
                                    type: 'POST',
                                    data: data,
                                    cache: false,
                                    dataType: 'json',
                                    processData: false, // Don't process the files
                                    contentType: false, // Set content type to false as jQuery will tell the server its a query string request
                                    success: function(data, textStatus, jqXHR) {
                                        //When succesful, update the UI to reflect this
                                        $("#save").attr("fileId", data);
                                        $("#save").trigger("fileIdupdated");
                                        console.log(data);
                                    },
                                    //If there was an error uploading, we log it.
                                    error: function(jqXHR, textStatus, errorThrown) {
                                        // Handle errors here
                                        console.log('ERRORS: ' + textStatus);
                                    // STOP LOADING SPINNER
                                    }
                                });
                            }
                        }, function() {});
                    }
                }).fail(function() {
                    //If we get an error loading the userProfile, we just export the save
                    markus.io.exportSave($('.doc').attr('filename'));
                });
            });
        // markus.io.exportSave($('.doc').attr('filename'));
        // createMarkupJobList();
        });

        //Registers the rollBack button, when you click this you reload the page
        $('#rollBack').on("click", function() {
            location.reload(); // createMarkupJobList();
        });

        //Registers the saveHTML button and provides it with the fileName
        $('#saveHTML').on("click", function() {
            markus.io.exportHTML($('.doc').attr('filename'));
        });

        //Registers the saveTei button and provides it with the fileName
        $('#saveTEI').on("click", function() {
            markus.io.exportTEI($('.doc').attr('filename'));
        });

        //Registers the exportSave button and provides it with the fileName
        $('#exportSAVE').on("click", function() {
            markus.io.exportSave($('.doc').attr('filename'));
        });

        // $(window).bind('beforeunload', function() {
        //   var lang = $(this).attr("lang");
        //   switch (lang) {
        //     case "zhtw":
        //       return '離開系統前有需要輸出存檔嗎 ?';
        //     default:
        //       return 'Do you want to export your save before leaving ?';
        //   }
        // });

        //Defines what happens when you click on the language Link
        $(".langLink").on("click", function(event) {

            event.preventDefault();

            //Get the language button clicked and set a cookie based on the language
            var lang = $(this).attr("lang");
            $.cookie('lang', lang, {
                path: '/'
            });

            //Registers the help functions to the provided language
            $("#helpModal").load("help" + lang + ".html", {}, function() {
                registHelp();
            });

            //Reload after changing of the language
            location.reload();
        });


    });
};
//Registers the navBar.register function to call the loadNavBar function
_m.navbar.register = function(_fn) {
    loadNavBar();
};
} )(markus);
;/**
 * reference.js base file.
 * @module reference.js
 */

/**
 * Registers the resize handler for the WebDictionary and registers the webDictionary
 * afterwards using the `markus.webDict.registWebDictionary()` function.
 *
 * @for Global
 * @method registWebDictionary
 */
var registWebDictionary = function() {
  //Resize handler
    markus.webDict.resize = function(obj) {
        $(obj).height($(window).height() - $("#content").offset().top - $("#buttonsRow").outerHeight() - 100);
    };
    markus.webDict.registWebDictionary();
};

/**
 * This method searches the CBDB using the input value of the provided webdictionary. If
 * there are multiple matches, display just one and create switcher buttons for the other matches.
 * When you click such a button `Global.searchCBDBID` is called
 *
 * @for Global
 * @method searchCBDB
 * @param  {Element} dictionary the dictionary element. Used to grab its `<input>` element
 */
var searchCBDB = function(dictionary) {
    //get the DB query
    var query = $(dictionary.input).val();
    //Hide the cbdbIDRef
    $("#cbdbIDRef").hide();

    //Find one or more digits
    if (query.match(/\d+/g)) {
        //If there are multiple, they are split along the '|' mark
        var cbdbids = query.split("|");

        //The markus webDictionary opens the url from the cbdb
        markus.webDict.openURL(dictionary, 'http://cbdb.fas.harvard.edu/cbdbapi/person.php?id=' + cbdbids[0]);

        //If there are multiple matches
        if (cbdbids.length > 1) {
            var txt = "";
            for (var i = 0; i < cbdbids.length; i++) {
                var cbdbid = cbdbids[i];
                //Create a button, if you click it. It searches for that person by ID
                txt += '<label class="btn btn-danger ' + ((i === 0) ? 'active' : 'noColor') + '" onclick="searchCBDBID(\'' + cbdbid + '\')"><input type="radio" name="options" id="' + cbdbid + '" >' + cbdbid + '</label>'
            }

            //Show the generated HTML text
            $("#cbdbIDRef").html(txt).show();
        }
    } else {
      //If it wasn't just digits, try `encodeURI` on it as a URL variable
        markus.webDict.openURL(dictionary, 'http://cbdb.fas.harvard.edu/cbdbapi/person.php?name=' + encodeURI(query));
    }


};

/**
 * Looks for a match in the CBDB using the idRef contained in the provided webdictionary.
 *
 * @for Global
 * @method searchByID
 * @param  {Element} dictionary reference to the webdictionary, used to grab its `<input>`
 */
var searchByID = function(dictionary) {
    //get the query from the input holder
    var query = $(dictionary.input).val();
    //get a reference to the idRef
    var idRef = $(dictionary.holder).find(".IDRef");
    //and hide it
    idRef.hide();

    //regex in the dictionary
    var regex = new RegExp(dictionary.idRegex);

    if (query.match(regex)) {
      //Once again, if there are multiple id's, split them on '|'
        var ids = query.split("|");
        //Open the first id
        markus.webDict.openURL(dictionary, dictionary.idSrc.replace(dictionary.param, ids[0]));

        //Generate buttons to switch to that id if there are multiple id's
        if (ids.length > 1) {
            var txt = "";
            for (var i = 0; i < ids.length; i++) {
                var id = ids[i];
                txt += '<label class="btn btn-danger ' + ((i === 0) ? 'active' : 'noColor') + '" onclick="searchFromID(\'' + dictionary.dictionary_name + '\',\'' + id + '\')"><input type="radio" name="options" id="' + id + '" >' + id + '</label>';
            }
            //Show the generated HTML containing the buttons
            idRef.html(txt).show();
        }
    } else {
      //Just open the url using the webdictionary
        markus.webDict.openURL(dictionary, dictionary.src.replace(dictionary.param, encodeURI($(dictionary.input).val())));
    }

};

/**
 * Opens the provided id in the dictionary referenced by the provided dictionary_name
 * as a string. Matches for that ID in the containing dictionary element are
 * given the `active` class
 *
 * @for Global
 * @method searchFromID
 * @param  {String} dictionary_name the name of the dictionary to find
 * @param  {String} id              the id to look for in the CBDB
 */
var searchFromID = function(dictionary_name, id) {
    //get the dictionary by name using JQUery and the name attribute
    var dictionary = $(".web-dictionary[web-dictionary-name='" + dictionary_name + "']");

    //Get each of the labels, containing a cbdbid
    $(dictionary).find("label").each(function() {
        //If we found a match to the id we're looking for
        if ($(this).find("#" + id).length > 0) {
            $(this).removeClass("noColor").addClass("active");
        } else {
            $(this).removeClass("active").addClass("noColor");
        }

    });

    //Returns the dictionary by that name
    dictionary = markus.webDict.getDictionary(dictionary_name);

    //Opens the url in that dictionary
    markus.webDict.openURL(dictionary, dictionary.idSrc.replace(dictionary.param, id));
};

/**
 * Searches trough the `#cbdbIDRef`. Finds matches for the provided id. If found
 * matches are given the `active` class. Then opens the url in the standard cbdb dictionary.
 *
 * @for Global
 * @method searchCBDBID
 * @param  {String} id the id of the cbdbid we're trying to match/find
 */
var searchCBDBID = function(id) {
    //Go through the cbdbdIdRef element and find each label for a match.
    $("#cbdbIDRef").find("label").each(function() {
      //If there is a match, make it active, else just display it without a color
        if ($(this).find("#" + id).length > 0) {
            $(this).removeClass("noColor").addClass("active");
        } else {
            $(this).removeClass("active").addClass("noColor");
        }
    });

    //Returns the dictionary that contains cbdb
    var dictionary = markus.webDict.getDictionary("cbdb");
    //Opens the url using that dictionary
    markus.webDict.openURL(dictionary, 'http://cbdb.fas.harvard.edu/cbdbapi/person.php?id=' + id);

};
;/**
 * summary.js base file.
 * @module summary.js
 */

 /**
 The class that holds the variables and functions created in the namespace of this file.
 The constrcutor of this object is only called once, because it is an anonymous function.

 @class summary.js_anonymous
 @constructor
 @param {Object}  _m a reference to the Markus Configuration Object is passed
 **/
( function(_m) {

/**
 * Converts an array of objects into TSV data to be saved. Shortcut to
 * `markus.data.objArrayToTSV`
 *
 * @method markupToTSV
 * @param  {Array} dataArray the data to be converted
 * @return {String}          the string that contains the converted TSV data
 */
var markupToTSV = function(dataArray) {
    return _m.data.objArrayToTSV(dataArray);
}


/**
 * Converts an array of objects into CSV data to be saved. Shortcut to
 * `markus.data.objArrayToCSV`
 *
 * @method markupToCSV
 * @param  {Array} dataArray the data to be converted
 * @return {String}          the string that contains the converted CSV data
 */
var markupToCSV = function(dataArray) {
    return _m.data.objArrayToCSV(dataArray);
}


/**
 * Converts an array of objects into HTML data to be saved. Shortcut to
 * `markus.data.objArrayToHTML`
 *
 * @method markupToHTMl
 * @param  {Array} dataArray the data to be converted
 * @return {String}          the string that contains the converted HTML data
 */
var markupToHTML = function(dataArray) {
    return _m.data.objArrayToHTML(dataArray);
}

/**
 * This function analyses the provided markupArray. It counts every type
 * or tag and saves these statistics in the returned `summary` object. For each
 * type or tag we count the unique and total occurences.
 *
 * @method markupTypeUniqueAndQuantitySummary
 * @param  {Array} markupArray contains the markup data to be analyzed
 * @return {Object}            contains the analysis data ordered by markup type
 */
var markupTypeUniqueAndQuantitySummary = function(markupArray) {
    var summary = {};
    for (var index in markupArray) {
        var tag = markupArray[index];
        // console.log(tag.type);

        //either continue counting if it is a known type, or initialize counting
        var typeCount = summary[tag.type] || {
                unique: 0,
                count: 0
            };
        var tagCount = typeCount[tag.tag];
        if (!tagCount) {
            tagCount = {
                count: 0
            };
            typeCount.unique++;
        }
        //Increase the occurence amount
        tagCount.count++;
        typeCount.count++;
        //Save the data in the saveObject for this type
        typeCount[tag.tag] = tagCount;
        //Save that object into the result object to be returned at the end
        summary[tag.type] = typeCount;
    }
    return summary;
}

/**
 * Exports the provided `dataArray` to a file ending in the provided `fileType`
 * extension using the provided `csvFn` function to create the data.
 *
 * @method exportCSV
 * @param  {Function} csvFn    the function that will transform the data to CSV
 * @param  {Array} dataArray  the data Array to be converted
 * @param  {String} fileType  the fileType extension of the file to save
 */
var exportCSV = function(csvFn, dataArray, fileType) {
  //Request a location to save the file.
    window.webkitRequestFileSystem(window.TEMPORARY, 1024 * 1024, function(fs) {
      //Try to find the file for the file we're working on
        fs.root.getFile($('.doc').attr('filename') + ".data." + fileType, {
            create: false
        }, function(fileEntry) {
            //If it exists, remove it
            fileEntry.remove(function() {
                console.log('File removed.');
                //and write a new version
                saveCSV(csvFn, dataArray, fileType);
            }, function() {
              //If it can't be removed, just write
                saveCSV(csvFn, dataArray, fileType);
            });
        }, function() {
          //If the file doesn't exist, just write
            saveCSV(csvFn, dataArray, fileType);
        });
    }, function() {
      //If we can't get access to the FS, just write
        saveCSV(csvFn, dataArray, fileType);
    });
}

/**
 * Writes the provided `dataArray` to a file with the `fileType` extension that
 * was provided using the `bloblFn` function to convert the `dataArray` to a
 * binary blob.
 *
 * @method save
 * @param  {Function} blobFn   the method to convert a dataArray to a Blob
 * @param  {Array} dataArray  the array containing the data
 * @param  {String} fileType  the fileType extension for the resulting saved file
 */
var save = function(blobFn, dataArray, fileType) {
  //Request acces to the fileSystem
    window.webkitRequestFileSystem(window.TEMPORARY, 1024 * 1024, function(fs) {
        console.log("exporting file");
        fs.root.getFile($('.doc').attr('filename') + ".data.xlsx", {
            create: true
        }, function(fileEntry) {
            fileEntry.createWriter(function(fileWriter) {
                var blob = blobFn(dataArray);
                fileWriter.addEventListener("writeend", function() {

                    $('#export').attr("href", fileEntry.toURL()).attr("download", $('.doc').attr('filename') + ".data." + fileType)
                    $('#export')[0].click();
                }, false);
                fileWriter.write(blob);

              //If we don't get WRITE access, log the error using the default error handler
            }, _m.util.errorHandler);

            //If we don't get access, log the error using the default error handler
        }, _m.util.errorHandler);
        //If we don't get access, log the error using the default error handler
    }, _m.util.errorHandler);
}

/**
 * Generates Microsoft Excel data from the provided `dataArray`.
 *
 * @method genXLSX
 * @param  {Array} dataArray the array to be converted into XLSX
 * @return {Blob}           a Blob containing the XLSX data
 */
var genXLSX = function(dataArray) {
  //Temporary HTML holder where we can store the HTML data generated by the markupToHTML function
    $("body").prepend($("<span id='saving_temp' style='display:none'>" + markupToHTML(dataArray) + "</span>"));
    var theTable = document.getElementById("exportTable");
    //Object array generated from the exporttable
    var oo = generateArray(theTable);
    var ranges = oo[1];

    /* original data */
    var data = oo[0];
    var ws_name = "MARKUS_EXPORT";
    // console.log(data);

    //Create a new Workbook, Excel file
    var wb = new Workbook();
    //Generate a sheet from array
    var ws = sheet_from_array_of_arrays(data);

    /* add ranges to worksheet */
    ws['!merges'] = ranges;

    /* add worksheet to workbook */
    wb.SheetNames.push(ws_name);
    //Attach the sheet to the workbook
    wb.Sheets[ws_name] = ws;

    //Generate a about workbook
    var wbout = XLSX.write(wb, {
        bookType: 'xlsx',
        bookSST: false,
        type: 'binary'
    });
    //Remove the temporary HTML holder for the data now that we're done
    $("#saving_temp").remove();

    //Return a new blob containing the output of the XLSX write function
    return new Blob([s2ab(wbout)], {
        type: "application/octet-stream"
    });

}

/**
 * Saves the provided `dataArray` to a file with the `fileType` extension using
 * the `csvFn` function.
 *
 * @method saveCSV
 * @param  {Function} csvFn     the funtion to convert array to csv
 * @param  {Array} dataArray the array of data
 * @param  {String} fileType  the extension of the saveFile
 */
var saveCSV = function(csvFn, dataArray, fileType) {
  //Request access to the FS
    window.webkitRequestFileSystem(window.TEMPORARY, 1024 * 1024, function(fs) {
        console.log("exporting file");
        //Try to get reference to the file
        fs.root.getFile($('.doc').attr('filename') + ".data." + fileType, {
            create: true
        }, function(fileEntry) {
          //Try to get write access to the file
            fileEntry.createWriter(function(fileWriter) {
                var blob = new Blob([csvFn(dataArray)]);
                fileWriter.addEventListener("writeend", function() {

                    $('#export').attr("href", fileEntry.toURL()).attr("download", $('.doc').attr('filename') + ".data." + fileType)
                    $('#export')[0].click();
                }, false);
                //Finally write to the file
                fileWriter.write(blob);
                //If there is an error along the way, log it with the default error handler
            }, _m.util.errorHandler);
        }, _m.util.errorHandler);
    }, _m.util.errorHandler);
};

/**
 * Defines the functions and variables availabe to the code outside of this file through
 * the `markus.summary` object. Uses some functions that have been defined in the summary.js_anonymous
 * namespace.
 *
 * @class Summary
 */
_m.summary = {
    /**
     * Saves the data filtered by the provided boolean flags to a XLSX file.
     * First calls `markus.data.getMarkupsArray` with the provided parameters,
     * then calls the `save` function from the summary.js_anonymous namespace
     * using the generated dataArray
     *
     * @method outputXLSX
     * @param  {boolean} withPassage     if we want the passage that contains the markup
     * @param  {boolean} withSupportText if we want surrounding text
     * @param  {number} noOfChars       the number of chars to include
     */
    outputXLSX: function(withPassage, withSupportText, noOfChars) {
        var dataArray = _m.data.getMarkupsArray(withPassage, withSupportText, noOfChars);
        save(genXLSX, dataArray, "xlsx");
    },
    /**
     * Array that holds data that can be saved. Empty by default.
     *
     * @type {Array}
     */
    dataArray: [],

    /**
     * Array that holds a summary of all the tag types. Empty by default
     *
     * @type {Array}
     */
    summaryArray: [],

    /**
     * Creates a summary of the document tags in a HTML table. Returns the generated HTML
     * upon completion.
     *
     * @return {String} the generated HTML table containing the document tag summary.
     */
    docTagSummary: function() {
        var dataArray = this.dataArray = _m.data.getMarkupsArray(true, false);
        var content = "";
        //Generate the summary using the markupTypeUniqueAndQuantitySummary function
        var summary = this.summaryArray = markupTypeUniqueAndQuantitySummary(dataArray);
        content = "<table class='table table-bordered table-condensed'><thead><tr><td>Type</td><td>Unique</td><td>Total</td></tr></thead><tbody>"

        //For each type we add a new row in the table
        for (var type in summary) {
            content += "<tr><td class='" + type + "'>" + type + "</td><td>" + summary[type].unique + "</td><td>" + summary[type].count + "</td></tr>";
        }
        //Finish of the table
        content += "</tbody></table>"

        //Return the generated data
        return content;
    },

    /**
     * Exports the markupsArray that is generated according to the provided parameters
     * (i.e. the two boolean flags and the number of characters requirement). Internally
     * uses the `markus.data.getMarkupsArray` function and the `exportCSV` function defined
     * in the summary.js_anonymous namespace.
     *
     * @method outputCSV
     * @param  {boolean} withPassage    Should we include the passage
     * @param  {boolean} withSupportText Should we include the supporting text
     * @param  {Integer} noOfChars       How many characters should we include
     */
    outputCSV: function(withPassage, withSupportText, noOfChars) {
        var dataArray = _m.data.getMarkupsArray(withPassage, withSupportText, noOfChars);
        exportCSV(markupToCSV, dataArray, "csv");
    },
    /**
     * Exports the markupsArray that is generated according to the provided parameters
     * (i.e. the two boolean flags and the number of characters requirement). Internally
     * uses the `markus.data.getMarkupsArray` function and the `exportCSV` function defined
     * in the summary.js_anonymous namespace.
     *
     * @method outputTSV
     * @param  {boolean} withPassage    Should we include the passage
     * @param  {boolean} withSupportText Should we include the supporting text
     * @param  {Integer} noOfChars       How many characters should we include
     */
    outputTSV: function(withPassage, withSupportText, noOfChars) {
        var dataArray = _m.data.getMarkupsArray(withPassage, withSupportText, noOfChars);
        exportCSV(markupToTSV, dataArray, "txt");
    },
    /**
     * Exports the markupsArray that is generated according to the provided parameters
     * (i.e. the two boolean flags and the number of characters requirement). Internally
     * uses the `markus.data.getMarkupsArray` function and the `exportCSV` function defined
     * in the summary.js_anonymous namespace.
     *
     * @method outputHTML
     * @param  {boolean} withPassage    Should we include the passage
     * @param  {boolean} withSupportText Should we include the supporting text
     * @param  {Integer} noOfChars       How many characters should we include
     */
    outputHTML: function(withPassage, withSupportText, noOfChars) {
        var dataArray = _m.data.getMarkupsArray(withPassage, withSupportText, noOfChars);
        exportCSV(markupToHTML, dataArray, "html");
    }

};

} )(markus);

/**
 * Registers the click handlers for the following buttons:
 * `#exportDataToCSV`, `#exportDataToTSV`, `#exportDataToHTML` and
 * `exportDataToXLSX`.
 *
 * Also defines the click behaviour of the show summary button that
 * shows a summary of the tag-usage of the document in a modal window.
 *
 * @for Global
 * @method registMarkupSummary
 */
var registMarkupSummary = function() {
    $("#exportDataToCSV").on("click", function() {
        var withPassage = $(".doc .passage").length > 0;
        var withSupportText = $("#withSupportText").prop("checked");
        var noOfChars = $("#noOfCharacter").val();
        markus.summary.outputCSV(withPassage, withSupportText, noOfChars);
    // $.exportCSV(tagToCSV,"csv");
    });
    $("#exportDataToTSV").on("click", function() {
        var withPassage = $(".doc .passage").length > 0;
        var withSupportText = $("#withSupportText").prop("checked");
        var noOfChars = $("#noOfCharacter").val();
        markus.summary.outputTSV(withPassage, withSupportText, noOfChars);
    // $.exportCSV(tagToTSV,"txt");
    });
    $("#exportDataToHTML").on("click", function() {
        var withPassage = $(".doc .passage").length > 0;
        var withSupportText = $("#withSupportText").prop("checked");
        var noOfChars = $("#noOfCharacter").val();
        markus.summary.outputHTML(withPassage, withSupportText, noOfChars);
    // $.exportCSV(tagToHTML,"html");
    });
    $("#exportDataToXLSX").on("click", function() {
        var withPassage = $(".doc .passage").length > 0;
        var withSupportText = $("#withSupportText").prop("checked");
        var noOfChars = $("#noOfCharacter").val();
        markus.summary.outputXLSX(withPassage, withSupportText, noOfChars);
    // $.exportCSV(tagToHTML,"html");
    });
    $("#showSummaryModalBtn").on("click", function() {
        $('#summaryModal a[href="#summary"]').tab('show');
        $("#summaryModal .tagSummary").html(markus.summary.docTagSummary());
        $("#summaryModal").modal("show");
    });
}

/**
 * Returns the egdes of the tags in an array.
 *
 * @method tagToEdges
 * @return {Array} array that holds the edges
 */
var tagToEdges = function() {
    var edges = [];
    var objArray = tagToJSON();
    var uniqueObjArray = [];
    //Generate an array of only the unique elements in the objArray variable
        var obj = objArray[index];
        for (var index in objArray) {
        var found = false;
        for (var _index in uniqueObjArray) {
            if (uniqueObjArray[_index].passageId == obj.passageId &&
                    uniqueObjArray[_index].type == obj.type &&
                    uniqueObjArray[_index].tag == obj.tag &&
                    uniqueObjArray[_index].id == obj.id || uniqueObjArray[_index].id == obj.id) {
                // console.log(uniqueObjArray[_index]);
                // console.log(obj);
                found = true;
                break;
            }
        }
        if (!found) {
            uniqueObjArray.push(obj);
        }
    }
    //Log both the lenghts
    console.log(objArray.length);
    console.log(uniqueObjArray.length);

    //If there are items in the uniqueObjArray
    if (uniqueObjArray.length > 0) {
        var perviousPassageId = null;
        var processedObjects = [];
        //For each of the items in the array
        for (var index in uniqueObjArray) {
            var obj = uniqueObjArray[index];

            //We get its passageId. If the previous passage is null or the passageID is not identical
            //to the previousPassageId, we reset it (i.e. we switch passage).
            var passageId = obj.passageId || "";
            if (perviousPassageId == null || passageId != perviousPassageId) {
                processedObjects = [];
                perviousPassageId = passageId;
            }
            ///For each of the entries in processedObjects
            for (var _index in processedObjects) {
                var sourceObj = processedObjects[_index];
                edges.push({
                    sourceType: sourceObj.type,
                    sourceTag: sourceObj.tag,
                    sourceId: sourceObj.id,
                    targetType: obj.type,
                    targetTag: obj.tag,
                    targetId: obj.id,
                    passageId: passageId
                });
            }
            processedObjects.push(obj);
        }
    }
    //The edge cases .
    return edges;
}
;/**
 * switcher.js base file.
 * @module switcher.js
 */


  /**
  The class that holds the variables and functions created in the namespace of this file.
  The constrcutor of this object is only called once, because it is an anonymous function.

  @class switcher.js_anonymous
  @constructor
  @param {Object}  _m a reference to the Markus Configuration Object is passed
  **/
( function(_m) {
//If the markus.ui object has not been defined yet, define it here
if (_m.ui == null) {
    _m.ui = {};
}


/**
 * Creates the `markus.ui.colorSwitcher` class. This class has only one method:
 * `regist(target, buttonSelector, doc)`.
 *
 * @class ColorSwitcher
 */
_m.ui.colorSwitcher = {
    /**
     * Registers what a color switcher does when it is clicked. When you click a
     * color switcher it switches through the different states of color:
     * `.noColor`, `.bordered`, no CSS class and back to `noColor` to complete the loop.
     *
     * @method regist
     * @param  {Element} target        the colorSwitcher element
     * @param  {String} buttonSelector Selector, only triggers color switch if this one is clicked
     * @param  {Element} doc           Reference to the document to find all other instances of this class
     */
    regist: function(target, buttonSelector, doc) {
      //log the target as a JQuery object
        console.log($(target));
        $(target).on("click", buttonSelector, function() {
            var colorSwitchedClass = $(this).attr("color-switcher-class");

            //If it was set at al
            if (colorSwitchedClass) {

                // noColor -> bordered -> no CSS Class -> no Color. ...

                if ($(this).hasClass("noColor")) {
                  //Remove the noColor class and tagReset from the tag clicked
                    $(this).removeClass("noColor").removeClass("tagReset");
                    $(this).addClass("bordered");
                    //Remove the noColor class and TagReset from all the other tags of this type
                    $(doc).find("." + colorSwitchedClass).removeClass("noColor").removeClass("tagReset");
                    // $(doc).find("." + colorSwitchedClass).removeClass("tagReset");
                    $(doc).find("." + colorSwitchedClass).addClass("bordered");
                    //Set its global status to bordered
                    markus.tag[colorSwitchedClass]["status"] = "bordered";

                } else if ($(this).hasClass("bordered")) {
                    //Remove the noColor and bordered class from the clicked element
                    $(this).removeClass("noColor");
                    $(this).removeClass("bordered");
                    $(this).addClass("tagReset");
                    //Remove the noColor and bordered class from all others of same type
                    $(doc).find("." + colorSwitchedClass).removeClass("noColor").removeClass("bordered");
                    $(doc).find("." + colorSwitchedClass).addClass("tagReset");
                    markus.tag[colorSwitchedClass]["status"] = "tagReset";
                } else if ($(this).hasClass("tagReset")) {
                    // $(this).addClass("noColor");
                    $(this).removeClass("bordered").removeClass("tagReset").removeClass("noColor");
                    $(doc).find("." + colorSwitchedClass).removeClass("bordered").removeClass("tagReset").removeClass("noColor");
                    markus.tag[colorSwitchedClass]["status"] = "";

                } else {
                    $(this).addClass("noColor");
                    $(this).removeClass("bordered").removeClass("tagReset");
                    $(doc).find("." + colorSwitchedClass).removeClass("bordered").removeClass("tagReset");
                    $(doc).find("." + colorSwitchedClass).addClass("noColor");
                    markus.tag[colorSwitchedClass]["status"] = "noColor";
                }
            }
        });
    }
};



} )(markus);


/**
 * Global function that registers the base color switcher
 *
 * @for Global
 * @method registColorSwitcher
 */
var registColorSwitcher = function() {
    markus.ui.colorSwitcher.regist("#buttonsRow", "button.switcher", ".doc");
}
;/**
 * tagRegex.js base file.
 * @module tagRegex.js
 */

 /**
 The class that holds the variables and functions created in the namespace of this file.
 The constrcutor of this object is only called once, because it is an anonymous function.

 @class tagRegex.js_anonymous
 @constructor
 @param {Object}  _m a reference to the Markus Configuration Object is passed
 **/
(function(_m) {
    /**
     * A function that returns a regular expresion based on the input
     *
     * @method tagRegexReplace
     * @param  {String} a UNUSED
     * @param  {String} b The tag name
     */
    var tagRegexReplace = function(a, b) {
        return "<[^>]{0,}" + b + "[^>]{0,}>[^<]{0,}<[^>]{0,}span>";
    };

    /**
     * Holds the regular expression pattern used to match against
     *
     * @property tagRegexPat
     * @type {Regex}
     */
    var tagRegexPat = /<([^>]{1,})>/g;

    /**
     * Creates the Regex class, that holds just one function: `translate`.
     * This translate function assembles a regular Expression based on the input.
     *
     * @class Regex
     */
    _m.regex = {

        /**
         * Translates one regular expression into another by replacing parts of it.
         *
         * @method translate
         * @param  {Regex} tagRegex the unmodified regular expression you want to translate
         */
        translate: function(tagRegex) {
            var regex = tagRegex.replace(tagRegexPat, tagRegexReplace);
            return regex;
        }
    };

})(markus);
;/**
 * ui.js base file.
 * @module ui.js
 */

 /**
 The class that holds the variables and functions created in the namespace of this file.
 The constrcutor of this object is only called once, because it is an anonymous function.

 Some of the functions defined in this class are later added to the MARKUS global object and can
 from that point on be called as `markus.ui.FUNCTION_NAME`

 @class ui.js_anonymous
 @constructor
 @param {Object}  _m a reference to the Markus Configuration Object is passed
 **/
( function(_m) {

/*
  require keypress.js
*/
/**
 * Create a new keyPress listener that listens to all keypresses in the whole window,
 * regardless of focus element. This object holds that listener
 *
 * @for UI
 * @property listener
 * @type {Listener}
 */
var listener = new window.keypress.Listener();

//Define the CTRL+S = save keyPresss
listener.simple_combo("meta s", function() {
    $("#save").trigger("click");
});
//Define the CTRL+' = edit document keyPress
listener.simple_combo("meta '", function() {
    $("#editDocBtn").trigger("click");
});
//Define the CTRL+J = show modal keypress
listener.simple_combo("meta j", function() {
    $("#showGotoModalBtn").trigger("click");
});
//Define the CTRL+D = Go through all the markups and remove them??
listener.simple_combo("meta d", function() {
    if ($('#popover').hasClass('in')){
        var countIndex = -1;
        var nextIndex = -1;
        var markups = $(".doc .markup");
        markups.each(function(){countIndex++; if ($(this).hasClass("selected")){nextIndex = countIndex +1}});
        $('#popover .glyphicon-trash').trigger("click");
        var obj = $(markups[nextIndex]);
        $(obj).trigger("click");
        if (!$(obj).isOnScreen()){
            $('html, body').animate({
                scrollTop: $(obj).offset().top - 100
            }, 200);
        }
    }
});

listener.simple_combo("meta =", function() {   
      
    var fontSize = $(".doc pre").css('font-size');
    
    if (fontSize){
        fontSize = parseInt(fontSize) + 1;

    } else {
        fontSize = "14";
        
    }
    $(".doc pre").css('font-size',fontSize+"px");
    return false;
});

listener.simple_combo("meta -", function() {   
    
    var fontSize = $(".doc pre").css('font-size');
    if (fontSize){
        fontSize = Math.max(10,parseInt(fontSize) - 1);

    } else {
        fontSize = "12";
        
    }
    $(".doc pre").css('font-size',fontSize+"px");
    return false;
});

/**
 * This method will transfer your focus from the currently selected markup instance
 * to the next one in the document with the same type.
 *
 * @for ui.js_anonymous
 * @method nextSameTypeMarkup
 */
function nextSameTypeMarkup(){
    //If there is an element selected we can find the next markup type
    if ($(".selected").length > 0){
      var countIndex = -1;
      var nextIndex = -1;

      //find the type of the markup we have selected right now
      var type = $(".doc .selected").attr("type");
      //get all the markups of that type
      var markups = $(".doc .markup."+type);

      //For each of the markups, find the one that is next to the selected one
      markups.each(function(){countIndex++; if ($(this).hasClass("selected")){nextIndex = countIndex +1}});

      //If the length is not longer than the array length
      if (markups.length > nextIndex) {
          //retrieve the markup that is the next one to the one we have currently selected
          var obj = $(markups[nextIndex]);
          //Trigger a click on it
          $(obj).trigger("click");
          //If it is not on screen yet, we animat to it
          if (!$(obj).isOnScreen()){
              $('html, body').animate({
                  scrollTop: $(obj).offset().top - 100
              }, 200);
          }
      }
    //If we have nothing selected, but we do have markup, we go to the first markup instance
    } else if ($(".doc .markup").length > 0){
      $($(".doc .markup")[0]).trigger("click");
    }
}

/**
 * Finds the next markup after the currently selected markup instance and will transfer
 * the focus by generating a click on the next element. This is markup_type agnostic.
 *
 * @for ui.js_anonymous
 * @method nextMarkup
 * @param  {Boolean} _sameType This Parameter is currently unused. TODO: Remove it, or fix it
 */
function nextMarkup(_sameType){
  //If we have an element selected, we start to look for the next element
  if ($(".selected").length > 0){
    var countIndex = -1;
    var nextIndex = -1;

    //Find all the generic markups
    var markups = $(".doc .markup");
    //Go through all of the markups and find the one that is selected, find the one after that
    markups.each(function(){countIndex++; if ($(this).hasClass("selected")){nextIndex = countIndex +1}});

    //Check if the nextIndex is actually a valid index in the array (index < array.length)
    if (markups.length > nextIndex) {
        //get the objet that must be the next markup
        var obj = $(markups[nextIndex]);
        //trigger a click on it
        $(obj).trigger("click");

        //and if it is not onscreen, smoothly scroll to it now
        if (!$(obj).isOnScreen()){
            $('html, body').animate({
                scrollTop: $(obj).offset().top - 100
            }, 200);
        }
    }
  //If we don't have any element selected, we just go to the first markup element and
  //trigger a click on it
  } else if ($(".doc .markup").length > 0){
    $($(".doc .markup")[0]).trigger("click");
  }
}

/**
 * Finds the previous markup before the currently selected markup instance and will transfer
 * the focus by generating a click on the previous element. This is markup_type agnostic.
 *
 * @for ui.js_anonymous
 * @method lastMarkup
 */
function lastMarkup(){
  //If we currently have something selected
  if ($(".selected").length > 0){
    var countIndex = -1;
    var nextIndex = -1;
    //Find all the markups in the document
    var markups = $(".doc .markup");

    //Go through all the markups and find the one that is the selected, go back one after that
    markups.each(function(){countIndex++; if ($(this).hasClass("selected")){nextIndex = countIndex -1}});
    //Check if that index is valid
    if (nextIndex > -1) {
        //Get the object at that index
        var obj = $(markups[nextIndex]);
        //Trigger a click on this markup
        $(obj).trigger("click");

        //If it is not currently onScreen, smoothly scroll to it
        if (!$(obj).isOnScreen()){
            $('html, body').animate({
                scrollTop: $(obj).offset().top - 100
            }, 200);
        }
    }
    //IF there is no current selection, we just focus on the first markup instance
  }else if ($(".doc .markup").length > 0){
    $($(".doc .markup")[0]).trigger("click");
  }
}

/**
 * Finds the previous markup before the currently selected markup instance and will transfer
 * the focus by generating a click on the previous element. This will only go through the instances
 * of the same markup_type.
 *
 * @for ui.js_anonymous
 * @method lastSameTypeMarkup
 */
function lastSameTypeMarkup(){
  //If we currently have an element selected
  if ($(".selected").length > 0){
    var countIndex = -1;
    var nextIndex = -1;
    //Find the type of the markup
    var type = $(".doc .selected").attr("type");
    //Find all the markups of that type
    var markups = $(".doc .markup."+type)

    //Go through all of them, find the selected one. go back one index to find the previous markup.
    markups.each(function(){countIndex++; if ($(this).hasClass("selected")){nextIndex = countIndex -1}});

    //If this is still a valid array index
    if (nextIndex > -1) {
        //Get the markup from the array
        var obj = $(markups[nextIndex]);
        //trigger a click on it
        $(obj).trigger("click");

        //If the markup is not on screen, smoothly scroll to it
        if (!$(obj).isOnScreen()){
            $('html, body').animate({
                scrollTop: $(obj).offset().top - 100
            }, 200);
        }
    }
    //If we didn't have anything selected right now
  }else if ($(".doc .markup").length > 0){
    //Just trigger a click on the first markup
    $($(".doc .markup")[0]).trigger("click");
  }
}

//Define that CTRL+RIGHT = goto next markup in the document
listener.register_combo({
    "keys"              : "meta right",
    "on_keyup"          : nextMarkup,
    "prevent_default"   : true,
    "is_exclusive"      : true
});

//Define that CTRL+SHIFT+RIGHT = goto next markup with same type in the document
listener.register_combo({
    "keys"              : "meta shift right",
    "on_keyup"          : nextSameTypeMarkup,
    "prevent_default"   : true,
    "is_exclusive"      : true
});
//Define that CTRL+LEFT = goto previous markup in the document
listener.register_combo({
    "keys"              : "meta left",
    "on_keyup"          : lastMarkup,
    "prevent_default"   : true,
    "is_exclusive"      : true
});
//Define that CTRL+SHIFT+LEFT = goto previous markup with same type in the document
listener.register_combo({
    "keys"              : "meta shift left",
    "on_keyup"          : lastSameTypeMarkup,
    "prevent_default"   : true,
    "is_exclusive"      : true
});


/**
 * Creates the markus.ui object and associates its member varaible listener with
 * the predefined listener variable from the ui.js_anonymous class. You can use this
 * class to gain access to the keyPress listener that was registered here.
 *
 * @class UI
 */

 if (_m.ui == null) {
    _m.ui = {};
 }
_m.ui.listener = listener;

} )(markus);
;/**
 * utilities.js base file.
 * @module utilities.js
 */

/**
The class that holds the variables and functions created in the namespace of this file.
The constrcutor of this object is only called once, because it is an anonymous function.

@class utilities.js_anonymous
@constructor
@param {Object}  _m a reference to the Markus Configuration Object is passed
**/
( function(_m) {
//Regular expressions used to find tags
var REMOVE_ALL_EXIST_TAG_REGEX = new RegExp("([^\\x00-\\xFF]*)", "gm");
var RECOVER_ALL_EXIST_TAG_REGEX = new RegExp("&amp;#\\([^\\)]{1,}\\);", "gm");

//defines the tagCSS and tag objects.
_m.tagCSS = {};
_m.tag = {};

/**
 * Escapes all unicode characters in the source that is passed as parameter and
 * returns the modified string.
 *
 * @for Util
 * @method convertToEscapeUnicode
 * @param  {String} source source
 * @return {String}        the unicode escaped string
 */
var convertToEscapeUnicode = function(source) {
    var result = [];
    for (var i = 0, j = source.length; i < j; i++) {
        if (source[i].match(/^[\x00-\xFF]*$/)) {
            result.push(source[i]);
        } else {
            result.push('&#(' + source.charCodeAt(i) + ');');
        }

    }
    return result.join("");
};

/**
 * Converts a unicode-escaped string generated using the `convertToEscapeUnicode` function back
 * to its unicode original. Pass a unicode-escaped string and get the unicode encoded string back.
 *
 * @for Util
 * @method converBackToUnicode
 * @param  {String} text the unicode-escaped string
 * @return {String}   the string containing unicode characters once again
 */
var converBackToUnicode = function(text) {
    var newValue = "";
    if (text.match(new RegExp("&(?:amp;){0,1}#\\(([^\\)]{1,})\\);", "gm"))) {

        newValue = text.replace(new RegExp("&(?:amp;){0,1}#\\(([^\\)]{1,})\\);", "gm"), function($0, $1, $2) {
            return String.fromCharCode($1);
        });
    } else {
        newValue = text;
    }
    return newValue;
};

/**
 * This is the default error handler. According to previous code documentation this function should be
 * moved to the `IO` package. This function does nothing but print 'Error: ' in front of the logging message
 * in the console.
 *
 * @method ERROR_HANDLER
 * @param  {Error} e the error that is encountered.
 */
var ERROR_HANDLER = function(e) {
    console.log('Error: ' + e.message);
};

//Find a String inside a tag
var REX_STRING_INSIDE_TAG = new RegExp("(<[^>]*>)", "gm");
//Working with PingYin.
var PINGYIN_CACHE = pinyinEngine.cache();

/**
The class that holds all the utility functions. This class is only declared once (technically a singleton).

@class Util
**/
_m.util = {
    /*
      Todo: need to decide either return null or return empty string if there is no param appeared

    */

   //defined above
    convertToEscapeUnicode: convertToEscapeUnicode,
  //defined above
    converBackToUnicode: converBackToUnicode,
    /**
     * This method will convert a Chinese character string to Ping Yin.
     *
     * @method chineseToPingYin
     * @param  {String} chineseString A string of Chinese Characters
     * @return {String} A string of Chinese annotated in Ping Yin
     */
    chineseToPingYin: function(chineseString) {
        var pingYin = [];
        for (var i = 0, j = chineseString.length; i < j; i++) {
            var pingYinChar;
            console.log(PINGYIN_CACHE[chineseString[i]]);
            if (!PINGYIN_CACHE[chineseString[i]]) {
                pingYinChar = chineseString[i];
            } else {
                var _temp = PINGYIN_CACHE[chineseString[i]][0];
                pingYinChar = _temp.charAt(0).toUpperCase() + _temp.slice(1);
            }
            pingYin.push(pingYinChar);
        }

        return pingYin.join("").split(' ').join('_');
    },

    /**
     * Reads the URL parameters that are included in the location (A.K.A the URL request bar
     * in the top of your browser. The address bar). Using this function you can request `GET` variables
     *
     * @method urlParam
     * @param  {String} param the name of the parameter we want to extract from the GET variables
     * @return {String}       the value of the parameter (probably URL encoded) as a String.
     */
    urlParam: function(param) {
        var results = new RegExp('[\\?&]' + param + '=([^&#]*)').exec(window.location.href);
        if (results === null) {
            return null;
        } else {
            return results[1] || 0;
        }
    },

    /**
     * Used to sort two comparable regex strings. This function is called  by
     * `array.sort`
     *
     * @method sortMergerdRegex
     * @param  {String} a Compare part A
     * @param  {String} b Compare part B
     * @return {Integer}   a number signifying if a should be before or after b
     */
    sortMergerdRegex: function(a, b) {
        var alength = a.indexOf("|");
        var blength = b.indexOf("|");
        if (alength < 0) {
            alength = a.length;
        }
        if (blength < 0) {
            blength = b.length;
        }
        return blength - alength;
    },

    /**
     * Removes duplicates from the passed array and returns only the unique
     * values found in that array.
     *
     * @method unique
     * @param  {Array} array the array to check for doubles
     * @return {Array}        the array that only contains the unique values from the input array
     */
    unique: function(array) {

        var temp = [];
        var result = [];
        for (var i = 0, j = array.length; i < j; i++) {
            temp[array[i]] = "";
        }
        for (var key in temp) {
            result.push(key);
        }
        return result;
    },

    /**
     * Makes sure that no embedded markup and tags can be created. Unwraps them using
     * JQuery.
     *
     * @method removeDuplicatedTags
     * @param  {Element} container The container to check for embedded markup
     */
    removeDuplicatedTags: function(container) {
        //finds instances of double markup embedding
        $(container).find(".markup > .markup").filter(function() {
            var parent = $(this).parent();
            return ($(this).text() === parent.text() && $(this).attr("type") === parent.attr("type"));
        }).contents().unwrap();
    },

    /**
     * Removes all remnants of tags using some more Regex magic
     *
     * @method removeAllExistTag
     * @param  {String} txt the text to remove the tags from
     * @return {String}     the cleaned string
     */
    removeAllExistTag: function(txt) {
        var newValue = txt.replace(
            REX_STRING_INSIDE_TAG, function($0, $1, $2) {
                if ($1.match(/^[\x00-\xFF]*$/)) {
                    return $1;
                } else {
                    return $1.replace(REMOVE_ALL_EXIST_TAG_REGEX, function($0, $1, $2) {
                        return convertToEscapeUnicode($1);
                    });
                }

            }
        );

        return newValue;
    },

    /**
     * Recovers all the existing tags using some Regex magic.
     *
     * @method recoverAllExistTag
     * @param  {String} txt the string we want to recover tags from
     * @return {String}     returns the newValue string in which the existing tags have been replaced
     */
    recoverAllExistTag: function(txt) {
        //Caching in a new object is not needed. Probably best to just
        //return the result of `txt.replace`
        var newValue = txt.replace(
            REX_STRING_INSIDE_TAG, function($0, $1, $2) {
                if ($1.match(RECOVER_ALL_EXIST_TAG_REGEX)) {

                    return $1.replace(new RegExp("&#\\(([^\\)]{1,})\\);", "gm"), function($0, $1, $2) {
                        return String.fromCharCode($1);
                    });
                } else {
                    return $1;
                }

            }
        );

        return newValue;
    },

    /**
     * Short hand for `markus.io.readFile`. Deprecated.
     *
     * @deprecated Use `markus.io.readFile`
     * @method setup_reader
     */
    setup_reader: markus.io.readFile,

    /**
     * Saves the current document and moves it to a new location. Another Shorthand
     * form, also deprecated?
     *
     * @method saveAndMove
     * @param  {String} page the url of the page you want to move to
     */
    saveAndMove: function(page) {
        var fileName = $(".doc").attr("fileName");
        markus.io.removeFile(fileName + ".html", function() {
            markus.io.save(fileName, function() {
                window.location = page + ".html?file=" + $(".doc").attr("fileName");
            });

        });
    },

    /**
     * Searches through all functions and tries to return it using the provided
     * pnamed parameter. It passes the function in its context. I.e:
     * You pass the string `"markus.io.readFile"` and as a return you get
     * the function `readFile` as a member of the `markus.io` object.
     *
     * @method searchFunctionByName
     * @param  {String} functionName Name of the function, preferred including the namespace.
     * @param  {Object} context     The object we're looking in.
     * @return {Function}           Returns the string you queried by name as a member of its context.
     */
    searchFunctionByName: function(functionName, context) {
        var namespaces = functionName.split(".");
        var func = namespaces.pop();
        for (var i = 0, j = namespaces.length; i < j; i++) {
            context = context[namespaces[i]];
        }
        return context[func];
    }

};

} )(markus);

/**
 * A reference to the last clicked markup. Should this be in the Global namespace?
 * @for Global
 * @type {Object}
 * @property clickedMarkup
 */
var clickedMarkup = null;

/**
 * A click handler for the `.doc` class from the document scope. It
 * removes any `.selected` class and hides the `popover`.
 */
$(document).on("click", ".doc", function() {
    $(".selected").removeClass("selected");
    $(".popover").hide();
    clickedMarkup = null;

    $(".justSelected.markup").removeClass("justSelected");
    // $(".justExtended").contents().unwrap();
    $(".justSelected,.justExtended").contents().unwrap();
});

/**
 * Handles the application cache events. If the application cache is ready for
 * an update, the application cache is swapped and the location is reloaded.
 *
 * @for Global
 * @method handleAppCache
 */
var handleAppCache = function() {
    if (applicationCache === undefined) {
        return;
    }

    if (applicationCache.status == applicationCache.UPDATEREADY) {
        applicationCache.swapCache();
        location.reload();
        return;
    }

    applicationCache.addEventListener('updateready', handleAppCache, false);
};
;/**
webDictionary.js file. This file contains the webDictionary definitions
@module webDictionary.js
*/

/**
The class that holds the variables and functions created in the namespace of this file.
The constrcutor of this object is only called once, because it is an anonymous function
@class webDictionary.js_anonymous
@constructor
@param {Object}  _m a reference to the Markus Configuration Object is passed
**/
(function(_m) {

    /**
     Function called before search. It hides the iframe of
     the dictionary and shows the spinHolder.

     @method _jobBeforeSearch
     @param {Object} dictionary The dictionary Object
     */
    var _jobBeforeSearch = function(dictionary) {
        $(dictionary.iframe).hide();
        $(dictionary.spinHolder).show();
    };

    /**
     Searches the dictionary for itself.

     @method searchDictionary
     @param {Object} dictionary the passed dictionary parameter
     */
    var searchDictionary = function(dictionary) {
        dictionary.search(dictionary);
    };

    /**
     All dictionaries are held in this one object
     @property dictionaries
     @type {Object}
     */
    var dictionaries = {};

    //Both local and markus referenced dictionary are set to new Object
    /**
    @property webDict
    @type {WebDictionary}
    */
    var webDict = _m.webDict = {};

    /**
     Define a search function. Uses the webDict object to open the URL
     specified in the dictionary object.
     @method _search
     @param {Object} dictionary the dictionary object
     */
    var _search = function(dictionary) {
        webDict.openURL(dictionary, dictionary.src.replace(dictionary.param, encodeURI($(dictionary.input).val())));
    };

    /**
     Web dictionary module handles the interaction between tab, input, spinner and iframe interactions.
    It does basic iframe URL construction from input value.
    @class WebDictionary
    */

    /**
     Resizes the passed object to match the window height.

     @method resize
     @param {Object} obj HTML object that has to match the window height
     */
    webDict.resize = function(obj) {
        $(obj).height($(window).height());
    };

    /**
     Sets all the parameters in a dictionary object to open the passed URL.

     @method openURL
     @param {Object} dictionary the passed dictionary object
     @param {String} url the URL string
     */
    webDict.openURL = function(dictionary, url) {
        //first call the preparation function before search
        _jobBeforeSearch(dictionary);

        //set the src attribute of the iframe to the provided URL
        $(dictionary.iframe).attr('src', url);

        //If the exportURL exists and is not a zero-length string, set the
        //href attribute of the exportLink to the exportURL.
        //Otherwise, set the href attribute of the exportLink to the passed URL
        if (dictionary.exportURL && dictionary.exportURL.length > 0) {
            $(dictionary.exportLink).attr('href', dictionary.exportURL.replace(dictionary.param, encodeURI($(dictionary.input).val())));
        } else {
            $(dictionary.exportLink).attr('href', url);
        }
    };

    /**
     Searches through all dictionaries by looping through the object that
     holds all defined dictionaries by key.

     @method searchAllDictionary
     */
    webDict.searchAllDictionary = function() {
        for (var key in dictionaries) {
            console.log(dictionaries[key]);
            searchDictionary(dictionaries[key]);
        }
    };

    /**
     Returns the specified webDictionary referenced by its name

     @method getDictionary
     @param {String} web_dictionary_name the name of the webDictionary you want to get
     @return {Object} the referenced webDictionary object
     */
    webDict.getDictionary = function(web_dictionary_name) {
        return dictionaries[web_dictionary_name];
    };

    /**
     Registers a new Web Dictionary

     @method registWebDictionary
     */
    webDict.registWebDictionary = function() {
        //Setting position for the web dictionary container
        $('.web-dictionary-container').affix({
            offset: {
                top: 0,
                bottom: function() {
                    return (this.bottom = $('.footer').outerHeight(true));
                }
            }
        });

        //For each of the web dictionaries convert it into a dictionary object
        $(".web-dictionary[web-dictionary-name]").each(function() {
            var obj = $(this),
                dictionary_name = $(this).attr("web-dictionary-name"), dictionary, web_dictionary_input, web_dictionary_button, web_dictionary_iframe, web_dictionary_spinHolder, web_dictionary_exportURL;

            //initializing the Dictionary object
            dictionaries[dictionary_name] = dictionary = {
                dictionary_name: dictionary_name,
                holder: obj,
                iframe: null,
                spinHolder: null,
                exportLink: null,
                idRegex: $(this).attr("web-dictionary-id-regex"),
                idSrc: $(this).attr("web-dictionary-id-src"),
                input: null,
                src: $(this).attr("web-dictionary-src"),
                exportURL: $(this).attr("web-dictionary-exportURL"),
                search: null,
                param: $(this).attr("web-dictionary-param")
            };

            //Use eval to set the web_dictionary_search, this should be a function
            var web_dictionary_search = eval($(this).attr("web-dictionary-search"));
            console.log(web_dictionary_search);

            //Check if we got the right type of data. If not, try to find the function
            //by name. If that fails, assign the search function to the one
            //defined above. (_search)
            if (typeof (web_dictionary_search) == "function") {
                dictionary.search = web_dictionary_search;
            } else if (web_dictionary_search != null && web_dictionary_search.length > 0) {
                dictionary.search = _m.util.searchFunctionByName(web_dictionary_search, window);
            } else {
                dictionary.search = _search;
            }

            //Assigns the Web Dictionary input and gives it an event handler
            //that searches the dictionary on change
            web_dictionary_input = obj.find(".web-dictionary-input");
            if (web_dictionary_input.length > 0) {
                dictionary.input = web_dictionary_input[0];
                $(dictionary.input).on('change', function() {
                    searchDictionary(dictionary);
                    // dictionary.openURL();
                });
            }

            //Set the iframe variable
            web_dictionary_iframe = obj.find(".web-dictionary-iframe");
            //Set the exportURL variable
            web_dictionary_exportURL = obj.find(".web-dictionary-exportURL");

            //If there is actually a non zero-length exportURL. Assign the
            //it to dictionary.exportLink.
            if (web_dictionary_exportURL.length > 0) {
                dictionary.exportLink = web_dictionary_exportURL[0];
            }

            //If there is actually a non zero-length iframe. Assign the
            //it to dictionary.iframe.
            if (web_dictionary_iframe.length > 0) {
                dictionary.iframe = web_dictionary_iframe[0];
            }

            //Assigns the spinHolder
            web_dictionary_spinHolder = obj.find(".web-dictionary-spinHolder");

            //If there are multiple, assign the first one
            if (web_dictionary_spinHolder.length > 0) {
                dictionary.spinHolder = web_dictionary_spinHolder[0];
            }

        });

        /**
         Debounces the specified function call.

         @for webDictionary.js_anonymous
         @method debouncer
         @param  {Function} func    the function you called and want to be debounced
         @param  {int} timeout the timeout of the debounce
         */
        var debouncer = function(func, timeout) {
            var timeoutID;
            timeout = timeout || 200;
            return function() {
                var scope = this ,
                    args = arguments;
                clearTimeout(timeoutID);
                timeoutID = setTimeout(function() {
                    func.apply(scope, Array.prototype.slice.call(args));
                }, timeout);
            };
        };

        /**
         * Defines what happens when you click on a tab. It shows the specified
         * tab, hides all webDicts, shows the correct one and triggers the
         * resetSize event.
         * @return {[type]} [description]
         */
        $(".web-dictionary-tab").on("click", function() {
            //show the current tab and get the dictionary name from the tab
            $(this).tab("show");
            var web_dictionary_name = $(this).attr("web-dictionary-name");
            // var index = $(".reference").find("a").index(this);

            //hide all web dictionaries and show only the correct one. trigger
            //a resetsize event
            $(".web-dictionary").hide();
            $(".web-dictionary[web-dictionary-name='" + web_dictionary_name + "']").show(function() {
                $(this).find(".web-dictionary-iframe").trigger("resetSize");
            });

        });


        /**
         * ResetSize handler for the iframe of the Web Dictionary
         */
        $('.web-dictionary-iframe').on('resetSize', function() {
            webDict.resize($(this));
            // $(this).height($(window).height() -$("#content").offset().top - $("#buttonsRow").outerHeight()-100);
        });

        /**
         * ResetSize handler for the container of the Web Dictionary
         */
        $('.web-dictionary-container').on('resetSize', function() {
            $(this).width($(this).parent().width());
        });

        /**
         * Affix handler for the container of the Web Dictionary
         */
        $('.web-dictionary-container').on('affixed.bs.affix', function() {
            $(this).trigger("resetSize");
        });

        /**
         * Load handler for the iframe of the Web Dictionary. Handles initializing
         */
        $('.web-dictionary-iframe').on('load', function() {
            var index = $(".web-dictionary").find("iframe").index(this);
            $(".web-dictionary").find(".web-dictionary-spinHolder").eq(index).hide();
            $(this).show();
            $(this).trigger('resetSize');
        });

        //Trigger resetSize
        $('.web-dictionary-iframe').trigger('resetSize');

        //When the window resizes, send a resize event to the Web Dictionary iframe
        //and container too. But debounce the events to prevent too many events
        //reaching the element.
        $(window).on("resize", debouncer(function() {
            $('.web-dictionary-iframe').trigger("resetSize");
            $('.web-dictionary-container').trigger("resetSize");
        }));

    };


})(markus);
